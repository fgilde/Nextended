using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Nextended.CodeGen.Attributes;
using Nextended.CodeGen.Contracts;
using System.Text;
using Nextended.CodeGen.Helper;

namespace Nextended.CodeGen.Generators;

public class ComSourceGenerator : ISourceSubGenerator<object>
{
    // Settings
    private const string DefaultPrefix = "Com";
    private const string DefaultNamespace = "CP.Server.Embedded.COM.AutoGenerated";
    private const string ComIdClassName = "ComGuids";
    private const string ComIdFormat = "Id{0}";
    private const string ComIdClassModifier = "internal";
    private const string ClassModifier = "public";
    private const string InterfaceModifier = "public";
    private const bool CreateRegions = true;
    private const bool CreateComments = true;
    private const bool GeneratePartial = true;

    // State
    private readonly Dictionary<string, string> _comIds = new();

    public void Execute(GeneratorExecutionContext context, IEnumerable<object> settings, AdditionalText additionalFile)
    {
        var symbols = SymbolTypes.Collect(context.Compilation);
        if (symbols.AutoGenerateCom == null) return;

        var types = Helpers.FindTypesWithAttribute(context.Compilation, symbols.AutoGenerateCom);
        var comTypeDict = types.ToDictionary(t => t.ToDisplayString(), t => t);

        // 1. Klassen, Interfaces, Enums
        var code = new StringBuilder();
        ComCode.EmitHeader(code, types);
        ComCode.EmitNamespaceOpen(code);

        int classCount = 0, interfaceCount = 0, enumCount = 0;

        foreach (var type in types)
        {
            if (type.TypeKind == TypeKind.Enum)
            {
                ComCode.EmitEnum(code, type, symbols, ref enumCount, _comIds);
                continue;
            }

            ComCode.EmitClassAndInterface(code, type, symbols, comTypeDict, _comIds, ref classCount, ref interfaceCount);
        }

        ComCode.EmitGuids(code, _comIds);
        ComCode.EmitFooter(code, classCount, interfaceCount, enumCount);

        context.AddSource("ComClasses.g.cs", code.ToString());

        // 2. Mapping Extensions
        var mapCode = new StringBuilder();
        MapCode.EmitMappingExtensions(mapCode, types, symbols, comTypeDict);
        context.AddSource("ComMappingExtensions.g.cs", mapCode.ToString());
    }

    // --- Helpers & Subcomponents ---
    class SymbolTypes
    {
        public INamedTypeSymbol? AutoGenerateCom, ComIgnore, ComPropertySetting;
        public static SymbolTypes Collect(Compilation c) => new()
        {
            AutoGenerateCom = c.GetTypeByMetadataName(typeof(AutoGenerateComAttribute).FullName!),
            ComIgnore = c.GetTypeByMetadataName(typeof(ComIgnoreAttribute).FullName!),
            ComPropertySetting = c.GetTypeByMetadataName(typeof(ComPropertySettingAttribute).FullName!)
        };
    }

    static class Helpers
    {
        public static List<INamedTypeSymbol> FindTypesWithAttribute(
            Compilation compilation, INamedTypeSymbol attributeType)
        {
            return (from tree in compilation.SyntaxTrees
                    let model = compilation.GetSemanticModel(tree)
                    let typeNodes = tree.GetRoot()
                        .DescendantNodes()
                        .Where(n => n is TypeDeclarationSyntax or EnumDeclarationSyntax)
                    from node in typeNodes
                    select model.GetDeclaredSymbol(node)).OfType<INamedTypeSymbol>()
                .Where(symbol => symbol.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeType)))
                .ToList();
        }

        public static string GetToComMethodName(INamedTypeSymbol type, INamedTypeSymbol autoGenAttr)
        {
            var info = type.GetAttributeInstance<AutoGenerateComAttribute>(autoGenAttr);
            if (!string.IsNullOrWhiteSpace(info.ToMethodName))
                return info.ToMethodName;
            return $"To{info.Prefix}{info.Suffix}";
        }

        public static string GetComClassName(
            INamedTypeSymbol type,
            INamedTypeSymbol autoGenAttr,
            bool asInterface)
        {
            var info = type.GetAttributeInstance<AutoGenerateComAttribute>(autoGenAttr);

            string main = !string.IsNullOrEmpty(info.ComClassName) ? info.ComClassName : type.Name;
            int idx = main.IndexOf('`');
            if (idx >= 0) main = main.Substring(0, idx);

            return $"{(asInterface ? "I" : "")}{info.Prefix}{main}{info.Suffix}";
        }

        public static string GetComPropertyName(IPropertySymbol prop, INamedTypeSymbol? settingAttr)
        {
            var info = prop.GetAttributeInstance<ComPropertySettingAttribute>(settingAttr);
            return !string.IsNullOrEmpty(info?.PropertyName) ? info.PropertyName : prop.Name;
        }
        public static IEnumerable<IPropertySymbol> GetComProperties(INamedTypeSymbol type, INamedTypeSymbol? ignoreAttr)
            => type.GetMembers().OfType<IPropertySymbol>().Where(p =>
                p.DeclaredAccessibility == Accessibility.Public &&
                !p.IsStatic &&
                (ignoreAttr == null || !p.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, ignoreAttr)))
            );
        public static bool IsNullable(IPropertySymbol prop)
            => prop.NullableAnnotation == NullableAnnotation.Annotated ||
               prop.Type is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T };


        public static bool IsComType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
            => comTypes.ContainsKey(type.ToDisplayString());
        public static bool IsComEnumType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
        {
            if (type is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nts)
                type = nts.TypeArguments[0];
            return comTypes.TryGetValue(type.ToDisplayString(), out var t) && t.TypeKind == TypeKind.Enum;
        }
        public static string GetComPropertyType(IPropertySymbol prop, Dictionary<string, INamedTypeSymbol> comTypes, INamedTypeSymbol autoGenAttr, bool asInterface)
        {
            var propType = prop.Type;
            bool isNullable = false;
            ITypeSymbol underlyingType = propType;
            if (propType is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nts)
            {
                isNullable = true;
                underlyingType = nts.TypeArguments[0];
            }
            string typeString;
            if (IsComEnumType(underlyingType, comTypes))
                typeString = GetComClassName(comTypes[underlyingType.ToDisplayString()], autoGenAttr, false);
            else if (IsComType(underlyingType, comTypes))
                typeString = GetComClassName(comTypes[underlyingType.ToDisplayString()], autoGenAttr, asInterface);
            else
                typeString = underlyingType.ToDisplayString();
            if (isNullable && !typeString.EndsWith("?"))
                typeString += "?";
            return typeString;
        }
        public static (string Id, string ClassName) GetGuid(string className, Dictionary<string, string> comIds)
        {
            if (!comIds.TryGetValue(className, out var guid))
            {
                guid = Guid.NewGuid().ToString();
                comIds[className] = guid;
            }
            return (guid, $"{ComIdClassName}.{string.Format(ComIdFormat, className)}");
        }
    }

    static class ComCode
    {
        public static void EmitHeader(StringBuilder sb, IEnumerable<INamedTypeSymbol> types)
        {
            sb.AppendFileHeader("COM Classes")
              .AppendUsings(types.Select(t => t.ContainingNamespace?.ToDisplayString()).Where(n => !string.IsNullOrWhiteSpace(n)).Concat(
                    ["System", "System.Runtime.InteropServices"]).Distinct().ToArray());
        }
        public static void EmitNamespaceOpen(StringBuilder sb)
        {
            sb.AppendLine($"namespace {DefaultNamespace}");
            sb.AppendLine("{");
            if (CreateRegions) sb.AppendLine("\t#region GENERATED CLASSES");
        }
        public static void EmitFooter(StringBuilder sb, int c, int i, int e)
        {
            sb.AppendLine($"\t// END CLASS GENERATION - GENERATED {c} CLASSES, {i} INTERFACES and {e} ENUMS");
            if (CreateRegions) sb.AppendLine("\t#endregion GENERATED CLASSES");
            sb.AppendLine("}");
        }
        public static void EmitGuids(StringBuilder sb, Dictionary<string, string> comIds)
        {
            sb.AppendLine("\t#region ComGuids");
            sb.AppendLine($"\t{ComIdClassModifier} static partial class {ComIdClassName}");
            sb.AppendLine("\t{");
            foreach (var kv in comIds)
                sb.AppendLine($"\t\tpublic const string {string.Format(ComIdFormat, kv.Key)} = \"{kv.Value}\";");
            sb.AppendLine("\t}");
            sb.AppendLine("\t#endregion ComGuids");
        }
        public static void EmitEnum(StringBuilder sb, INamedTypeSymbol enumType, SymbolTypes symbols, ref int count, Dictionary<string, string> comIds)
        {
            var comName = Helpers.GetComClassName(enumType, symbols.AutoGenerateCom!, false);
            if (CreateComments) sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{enumType.ToDisplayString()}\"/></summary>");
            sb.AppendLine("\t[ComVisible(true)]");
            sb.AppendLine($"\t[Guid({Helpers.GetGuid(comName, comIds).ClassName})]");
            sb.AppendLine($"\t{ClassModifier} enum {comName}");
            sb.AppendLine("\t{");
            int dispId = 0;
            foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>().Where(f => f.IsConst))
            {
                if (symbols.ComIgnore != null && member.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, symbols.ComIgnore)))
                    continue;
                if (CreateComments) sb.AppendLine($"\t\t/// <summary>{member.Name}</summary>");
                sb.AppendLine($"\t\t[DispId({++dispId})]");
                sb.AppendLine($"\t\t{member.Name} = {member.ConstantValue},");
            }
            sb.AppendLine("\t}\n");
            count++;
        }
        public static void EmitClassAndInterface(StringBuilder sb, INamedTypeSymbol type, SymbolTypes symbols, Dictionary<string, INamedTypeSymbol> comTypeDict, Dictionary<string, string> comIds, ref int c, ref int i)
        {
            var comName = Helpers.GetComClassName(type, symbols.AutoGenerateCom!, false);
            var comInterfaceName = Helpers.GetComClassName(type, symbols.AutoGenerateCom!, true);
            if (CreateRegions) sb.AppendLine($"\t#region COM For {comName}");

            // Interface
            if (CreateComments)
                sb.AppendLine($"\t/// <summary>{comInterfaceName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
            sb.AppendLine($"\t[ComVisible(true)]");
            sb.AppendLine($"\t[Guid({Helpers.GetGuid(comName, comIds).ClassName})]");
            sb.AppendLine("\t[TypeLibType(TypeLibTypeFlags.FDual | TypeLibTypeFlags.FDispatchable)]");
            sb.AppendLine($"\t{InterfaceModifier} {(GeneratePartial ? "partial " : "")}interface {comInterfaceName}");
            sb.AppendLine("\t{");
            int dispId = 0;
            foreach (var prop in Helpers.GetComProperties(type, symbols.ComIgnore))
            {
                var propTypeString = Helpers.GetComPropertyType(prop, comTypeDict, symbols.AutoGenerateCom!, true);
                var propName = Helpers.GetComPropertyName(prop, symbols.ComPropertySetting);
                sb.AppendLine($"\t\t[DispId({++dispId})]");
                sb.AppendLine($"\t\t{propTypeString} {propName} {{ get; set; }}");
            }
            sb.AppendLine("\t}\n");
            i++;

            // Klasse
            if (CreateComments)
                sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
            sb.AppendLine($"\t[ComVisible(true)]");
            sb.AppendLine($"\t[Guid({Helpers.GetGuid(comName, comIds).ClassName})]");
            sb.AppendLine($"\t{ClassModifier} {(GeneratePartial ? "partial " : "")}class {comName} : {comInterfaceName}");
            sb.AppendLine("\t{");
            foreach (var prop in Helpers.GetComProperties(type, symbols.ComIgnore))
            {
                var propTypeString = Helpers.GetComPropertyType(prop, comTypeDict, symbols.AutoGenerateCom!, false);
                var propName = Helpers.GetComPropertyName(prop, symbols.ComPropertySetting);
                sb.AppendLine($"\t\tpublic {propTypeString} {propName} {{ get; set; }}");
            }
            foreach (var prop in Helpers.GetComProperties(type, symbols.ComIgnore))
            {
                var propType = prop.Type;
                if (Helpers.IsComType(propType, comTypeDict) && !Helpers.IsComEnumType(propType, comTypeDict))
                {
                    var propTypeString = Helpers.GetComPropertyType(prop, comTypeDict, symbols.AutoGenerateCom!, false);
                    var comInterfaceTypeName = Helpers.GetComClassName(comTypeDict[propType.ToDisplayString()], symbols.AutoGenerateCom!, true);
                    var thisInterface = comInterfaceName;
                    var propName = Helpers.GetComPropertyName(prop, symbols.ComPropertySetting);
                    sb.AppendLine($"\t\t{comInterfaceTypeName} {thisInterface}.{propName} {{ get => {propName}; set => {propName} = ({propTypeString})value; }}");
                }
            }
            sb.AppendLine("\t}\n");
            c++;
            if (CreateRegions) sb.AppendLine($"\t#endregion COM For {comName}");
        }
    }

    static class MapCode
    {
        public static void EmitMappingExtensions(StringBuilder sb, List<INamedTypeSymbol> types, SymbolTypes symbols, Dictionary<string, INamedTypeSymbol> comTypeDict)
        {
            sb.AppendLine("using System;");
            sb.AppendLine($"namespace {DefaultNamespace}");
            sb.AppendLine("{");
            sb.AppendLine("\tpublic static partial class MappingExtensions");
            sb.AppendLine("\t{");

            foreach (var type in types)
            {
                var toComMethodName = Helpers.GetToComMethodName(type, symbols.AutoGenerateCom!);
                var isEnum = type.TypeKind == TypeKind.Enum;
                var netTypeName = type.ToDisplayString();
                var comTypeName = Helpers.GetComClassName(type, symbols.AutoGenerateCom!, false);
                if (isEnum)
                {
                    // Nullable
                    sb.AppendLine($"\t\tpublic static {comTypeName}? {toComMethodName}(this {netTypeName}? src) => src.HasValue ? ({comTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\tpublic static {netTypeName}? ToNet(this {comTypeName}? src) => src.HasValue ? ({netTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\tpublic static {comTypeName} {toComMethodName}(this {netTypeName} src) => ({comTypeName})(int)src;");
                    sb.AppendLine($"\t\tpublic static {netTypeName} ToNet(this {comTypeName} src) => ({netTypeName})(int)src;");
                    continue;
                }

                var comProps = Helpers.GetComProperties(type, symbols.ComIgnore).ToList();

                // ToCom
                sb.AppendLine($"\t\tpublic static {comTypeName} {toComMethodName}(this {netTypeName} src)");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(src == null) return null;");
                sb.AppendLine($"\t\t\tvar result = new {comTypeName}();");
                foreach (var prop in comProps)
                {
                    var netPropName = prop.Name;
                    var comPropName = Helpers.GetComPropertyName(prop, symbols.ComPropertySetting);
                    var netPropType = prop.Type;

                    if (Helpers.IsComEnumType(netPropType, comTypeDict))
                    {
                        var enumType = netPropType.UnwrapNullableTypeSymbol();
                        var enumToComMethod = Helpers.GetToComMethodName(comTypeDict[enumType.ToDisplayString()], symbols.AutoGenerateCom!);

                        sb.AppendLine(Helpers.IsNullable(prop)
                            ? $"\t\t\tresult.{comPropName} = src.{netPropName}?.{enumToComMethod}();"
                            : $"\t\t\tresult.{comPropName} = src.{netPropName}.{enumToComMethod}();");
                    }
                    else if (Helpers.IsComType(netPropType, comTypeDict))
                    {
                        var classType = netPropType.UnwrapNullableTypeSymbol();
                        var propToComMethod = Helpers.GetToComMethodName(comTypeDict[classType.ToDisplayString()], symbols.AutoGenerateCom!);

                        sb.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName}?.{propToComMethod}();");
                    }
                    else
                    {
                        sb.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName};");
                    }
                }

                sb.AppendLine("\t\t\treturn result;");
                sb.AppendLine("\t\t}");

                // ToNet
                sb.AppendLine($"\t\tpublic static {netTypeName} ToNet(this {comTypeName} src)");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(src == null) return null;");
                sb.AppendLine($"\t\t\tvar result = new {netTypeName}();");
                foreach (var prop in comProps)
                {
                    var netPropName = prop.Name;
                    var comPropName = Helpers.GetComPropertyName(prop, symbols.ComPropertySetting);
                    var netPropType = prop.Type;

                    if (Helpers.IsComEnumType(netPropType, comTypeDict))
                        sb.AppendLine(Helpers.IsNullable(prop)
                            ? $"\t\t\tresult.{netPropName} = src.{comPropName}?.ToNet();"
                            : $"\t\t\tresult.{netPropName} = src.{comPropName}.ToNet();");
                    else if (Helpers.IsComType(netPropType, comTypeDict))
                        sb.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName}?.ToNet();");
                    else
                        sb.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName};");
                }
                sb.AppendLine("\t\t\treturn result;");
                sb.AppendLine("\t\t}");
            }

            sb.AppendLine("\t}");
            sb.AppendLine("}");
        }
    }
}
