using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Nextended.CodeGen.Attributes;
using Nextended.CodeGen.Contracts;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
//using Nextended.Core.Extensions;

namespace Nextended.CodeGen.Generators;

public class ComSourceGenerator : ISourceSubGenerator<object>
{
    private const string comIdClassName = "ComGuids";
    private const string comIdFormat = "Id{0}";
    private const string comIdClassModifier = "internal";
    private const string classModifier = "public";
    private const string interfaceModifier = "public";
    private const bool createRegions = true;
    private const bool createComments = true;
    private const bool generatePartial = true;
    private const string defaultPrefix = "Com";
    private const string defaultNamespace = "CP.Server.Embedded.COM.AutoGenerated";

    private readonly Dictionary<string, string> comIds = new();

    public void Execute(GeneratorExecutionContext context, IEnumerable<object> settings, AdditionalText additionalFile)
    {
        var autoGenAttr = context.Compilation.GetTypeByMetadataName(typeof(AutoGenerateComAttribute).FullName);
        var comIgnoreAttr = context.Compilation.GetTypeByMetadataName(typeof(ComIgnoreAttribute).FullName);
        var comPropertySettingAttr = context.Compilation.GetTypeByMetadataName(typeof(ComPropertySettingAttribute).FullName);
       // var comAliasNameAttr = context.Compilation.GetTypeByMetadataName(typeof(ComAliasNameAttribute).FullName);

        if (autoGenAttr == null)
            return;

        // Finde alle mit [AutoGenerateCom] markierten Klassen/Structs/Enums im Projekt
        var typesWithAttr = new List<INamedTypeSymbol>();

        foreach (var tree in context.Compilation.SyntaxTrees)
        {
            var semanticModel = context.Compilation.GetSemanticModel(tree);

            // Klassen/Structs/Interfaces (TypeDeclarationSyntax)
            foreach (var typeDecl in tree.GetRoot().DescendantNodes().OfType<TypeDeclarationSyntax>())
            {
                var symbol = semanticModel.GetDeclaredSymbol(typeDecl) as INamedTypeSymbol;
                if (symbol == null) continue;
                if (symbol.GetAttributes().Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, autoGenAttr)))
                    typesWithAttr.Add(symbol);
            }

            // Enums (EnumDeclarationSyntax)
            foreach (var enumDecl in tree.GetRoot().DescendantNodes().OfType<EnumDeclarationSyntax>())
            {
                var symbol = semanticModel.GetDeclaredSymbol(enumDecl) as INamedTypeSymbol;
                if (symbol == null) continue;
                if (symbol.GetAttributes().Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, autoGenAttr)))
                    typesWithAttr.Add(symbol);
            }
        }


        // "COM-Typ-Cache" für Typ-Name <-> Symbol
        var comTypeDict = typesWithAttr.ToDictionary(t => t.ToDisplayString(), t => t);

        // --- 1. Com-Klassen und -Interfaces erzeugen ---
        var sb = new StringBuilder();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// --- AUTO GENERATED CODE ({DateTime.Now:G}) ---");
        sb.AppendLine("/// --- COM Klassen ---");
        sb.AppendLine("/// </summary>\n");
        // Usings
        foreach (var ns in typesWithAttr.Select(t => t.ContainingNamespace?.ToDisplayString()).Where(n => !string.IsNullOrWhiteSpace(n)).Distinct())
            sb.AppendLine($"using {ns};");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.InteropServices;\n");

        sb.AppendLine($"namespace {defaultNamespace}");
        sb.AppendLine("{");
        if (createRegions) sb.AppendLine("\t#region GENERATED CLASSES");

        int classCount = 0, interfaceCount = 0, enumCount = 0;

        foreach (var type in typesWithAttr)
        {
            var isEnum = type.TypeKind == TypeKind.Enum;
            if (isEnum)
            {
                WriteComEnum(sb, type, comIgnoreAttr, autoGenAttr);
                enumCount++;
                continue;
            }

            var comName = GetComClassName(type, autoGenAttr, false);
            var comInterfaceName = GetComClassName(type, autoGenAttr, true);

            if (createRegions) sb.AppendLine($"\t#region COM For {comName}");

            // Interface
            if (createComments)
                sb.AppendLine($"\t/// <summary>{comInterfaceName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
            sb.AppendLine($"\t[ComVisible(true)]");
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
            sb.AppendLine("\t[TypeLibType(TypeLibTypeFlags.FDual | TypeLibTypeFlags.FDispatchable)]");
            sb.AppendLine($"\t{interfaceModifier} {(generatePartial ? "partial " : "")}interface {comInterfaceName}");
            sb.AppendLine("\t{");
            int dispId = 0;
            foreach (var prop in GetComProperties(type, comIgnoreAttr))
            {
                var propTypeString = GetComPropertyType(prop, comTypeDict, autoGenAttr, true);
                var propName = GetComPropertyName(prop, comPropertySettingAttr);
                sb.AppendLine($"\t\t[DispId({++dispId})]");
                sb.AppendLine($"\t\t{propTypeString} {propName} {{ get; set; }}");
            }
            sb.AppendLine("\t}\n");
            interfaceCount++;

            // Klasse
            if (createComments)
                sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
            sb.AppendLine($"\t[ComVisible(true)]");
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
            sb.AppendLine($"\t{classModifier} {(generatePartial ? "partial " : "")}class {comName} : {comInterfaceName}");
            sb.AppendLine("\t{");
            foreach (var prop in GetComProperties(type, comIgnoreAttr))
            {
                var propTypeString = GetComPropertyType(prop, comTypeDict, autoGenAttr, false);
                var propName = GetComPropertyName(prop, comPropertySettingAttr);
                sb.AppendLine($"\t\tpublic {propTypeString} {propName} {{ get; set; }}");
            }
            foreach (var prop in GetComProperties(type, comIgnoreAttr))
            {
                var propType = prop.Type;
                if (IsComType(propType, comTypeDict) && !IsComEnumType(propType, comTypeDict))
                {
                    var propTypeString = GetComPropertyType(prop, comTypeDict, autoGenAttr, false);
                    var comInterfaceTypeName = GetComClassName(comTypeDict[propType.ToDisplayString()], autoGenAttr, true);
                    var thisInterface = GetComClassName(type, autoGenAttr, true);
                    var propName = GetComPropertyName(prop, comPropertySettingAttr);

                    sb.AppendLine($"\t\t{comInterfaceTypeName} {thisInterface}.{propName} " + "{");
                    sb.AppendLine($"\t\t\tget => {propName};");
                    sb.AppendLine($"\t\t\tset => {propName} = ({propTypeString})value;");
                    sb.AppendLine("\t\t}");
                }
            }

            sb.AppendLine("\t}\n");
            classCount++;

            if (createRegions) sb.AppendLine($"\t#endregion COM For {comName}");
        }

        // Guids
        sb.AppendLine("\t#region ComGuids");
        sb.AppendLine($"\t{comIdClassModifier} static partial class {comIdClassName}");
        sb.AppendLine("\t{");
        foreach (var kv in comIds)
            sb.AppendLine($"\t\tpublic const string {string.Format(comIdFormat, kv.Key)} = \"{kv.Value}\";");
        sb.AppendLine("\t}");
        sb.AppendLine("\t#endregion ComGuids");

        sb.AppendLine($"\t// END CLASS GENERATION - GENERATED {classCount} CLASSES, {interfaceCount} INTERFACES and {enumCount} ENUMS");
        if (createRegions) sb.AppendLine("\t#endregion GENERATED CLASSES");
        sb.AppendLine("}");

        context.AddSource("ComClasses.g.cs", sb.ToString());

        // --- 2. Mapping Extensions ---
        var sbMap = new StringBuilder();
        sbMap.AppendLine("using System;");
        sbMap.AppendLine($"namespace {defaultNamespace}");
        sbMap.AppendLine("{");
        sbMap.AppendLine("\tpublic static partial class MappingExtensions");
        sbMap.AppendLine("\t{");

        foreach (var type in typesWithAttr)
        {
            var isEnum = type.TypeKind == TypeKind.Enum;
            var netTypeName = type.ToDisplayString();
            var comTypeName = GetComClassName(type, autoGenAttr, false);
            if (isEnum)
            {
                sbMap.AppendLine($"\t\tpublic static {comTypeName}? ToCom(this {netTypeName}? src)");
                sbMap.AppendLine("\t\t{");
                sbMap.AppendLine("\t\t\tif(src == null) return null;");
                sbMap.AppendLine($"\t\t\treturn ({comTypeName})(int)src.Value;");
                sbMap.AppendLine("\t\t}");

                sbMap.AppendLine($"\t\tpublic static {netTypeName}? ToNet(this {comTypeName}? src)");
                sbMap.AppendLine("\t\t{");
                sbMap.AppendLine("\t\t\tif(src == null) return null;");
                sbMap.AppendLine($"\t\t\treturn ({netTypeName})(int)src.Value;");
                sbMap.AppendLine("\t\t}");

                // Optional: Non-nullable Variant
                sbMap.AppendLine($"\t\tpublic static {comTypeName} ToCom(this {netTypeName} src) => ({comTypeName})(int)src;");
                sbMap.AppendLine($"\t\tpublic static {netTypeName} ToNet(this {comTypeName} src) => ({netTypeName})(int)src;");
                continue;
            }


            var comProps = GetComProperties(type, comIgnoreAttr).ToList();

            // ToCom
            sbMap.AppendLine($"\t\tpublic static {comTypeName} ToCom(this {netTypeName} src)");
            sbMap.AppendLine("\t\t{");
            sbMap.AppendLine("\t\t\tif(src == null) return null;");
            sbMap.AppendLine($"\t\t\tvar result = new {comTypeName}();");
            foreach (var prop in comProps)
            {
                var netPropName = prop.Name;
                var comPropName = GetComPropertyName(prop, comPropertySettingAttr);
                var netPropType = prop.Type;

                // Prüfe, ob das Property ein Enum ist
                if (IsComEnumType(netPropType, comTypeDict))
                {
                    if (IsNullable(prop))
                        sbMap.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName}?.ToCom();");
                    else
                        sbMap.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName}.ToCom();");
                }
                else if (IsComType(netPropType, comTypeDict))
                {
                    sbMap.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName}?.ToCom();");
                }
                else
                {
                    sbMap.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName};");
                }
            }

            sbMap.AppendLine("\t\t\treturn result;");
            sbMap.AppendLine("\t\t}");

            // ToNet
            sbMap.AppendLine($"\t\tpublic static {netTypeName} ToNet(this {comTypeName} src)");
            sbMap.AppendLine("\t\t{");
            sbMap.AppendLine("\t\t\tif(src == null) return null;");
            sbMap.AppendLine($"\t\t\tvar result = new {netTypeName}();");
            foreach (var prop in comProps)
            {
                var netPropName = prop.Name;
                var comPropName = GetComPropertyName(prop, comPropertySettingAttr);
                var netPropType = prop.Type;

                if (IsComEnumType(netPropType, comTypeDict))
                {
                    if (IsNullable(prop))
                        sbMap.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName}?.ToNet();");
                    else
                        sbMap.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName}.ToNet();");
                }
                else if (IsComType(netPropType, comTypeDict))
                {
                    sbMap.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName}?.ToNet();");
                }
                else
                {
                    sbMap.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName};");
                }
            }
            sbMap.AppendLine("\t\t\treturn result;");
            sbMap.AppendLine("\t\t}");
        }

        sbMap.AppendLine("\t}");
        sbMap.AppendLine("}");

        context.AddSource("ComMappingExtensions.g.cs", sbMap.ToString());
    }

    private void WriteComEnum(
        StringBuilder sb,
        INamedTypeSymbol enumType,
        INamedTypeSymbol comIgnoreAttr,
        INamedTypeSymbol autoGenAttr)
    {
        var comName = GetComClassName(enumType, autoGenAttr, false);

        if (createComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{enumType.ToDisplayString()}\"/></summary>");
        sb.AppendLine("\t[ComVisible(true)]");
        sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLine($"\t{classModifier} enum {comName}");
        sb.AppendLine("\t{");

        int dispId = 0;
        foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>().Where(f => f.IsConst))
        {
            // Enum-Member mit [ComIgnore] überspringen
            if (member.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, comIgnoreAttr)))
                continue;

            // (Optional: Kommentar zum Enum-Member einfügen)
            if (createComments)
                sb.AppendLine($"\t\t/// <summary>{member.Name}</summary>");
            sb.AppendLine($"\t\t[DispId({++dispId})]");
            sb.AppendLine($"\t\t{member.Name} = {member.ConstantValue},");
        }

        sb.AppendLine("\t}");
        sb.AppendLine();
    }


    // ------------- Hilfsmethoden -------------
    private (string Id, string ClassName) GetGuid(string className)
    {
        if (!comIds.TryGetValue(className, out var guid))
        {
            guid = CreateGuid(className);
            comIds[className] = guid;
        }
        return (guid, $"{comIdClassName}.{string.Format(comIdFormat, className)}");
    }
    private static bool IsComEnumType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
    {
        if (type is INamedTypeSymbol nts &&
            nts.IsGenericType &&
            nts.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T)
        {
            type = nts.TypeArguments[0];
        }

        return comTypes.TryGetValue(type.ToDisplayString(), out var t) && t.TypeKind == TypeKind.Enum;
    }


    private static string CreateGuid(string input)
    {
        return Guid.NewGuid().ToString();
        //return input.GetHashCode().ToGuid().ToString();
        //var hash = System.Security.Cryptography.SHA1.HashData(Encoding.UTF8.GetBytes(input));
        //byte[] guidData = new byte[16];
        //Array.Copy(hash, guidData, 16);
        //return new Guid(guidData).ToString();
    }

    private static string GetComClassName(INamedTypeSymbol type, INamedTypeSymbol autoGenAttr, bool asInterface)
    {
        var attr = type.GetAttributes().FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, autoGenAttr));
        string prefix = defaultPrefix;
        string suffix = "";
        string nameOverride = null;
        if (attr != null)
        {
            foreach (var arg in attr.NamedArguments)
            {
                if (arg.Key == "Prefix" && arg.Value.Value is string s1) prefix = s1;
                if (arg.Key == "Suffix" && arg.Value.Value is string s2) suffix = s2;
                if (arg.Key == "ComClassName" && arg.Value.Value is string s3) nameOverride = s3;
            }
        }
        string mainClassName = nameOverride ?? type.Name;
        if (mainClassName.Contains("`")) mainClassName = mainClassName.Substring(0, mainClassName.IndexOf('`'));
        string extras = "";
        if (type.IsGenericType && type.TypeArguments.Length > 0)
            extras = string.Join("", type.TypeArguments.Select(t => t.Name));
        return $"{(asInterface ? "I" : "")}{prefix}{mainClassName}{extras}{suffix}";
    }

    private static string GetComPropertyName(IPropertySymbol prop, INamedTypeSymbol comPropertySettingAttr)
    {
        var attr = prop.GetAttributes().FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, comPropertySettingAttr));
        if (attr != null)
        {
            var namedArg = attr.NamedArguments.FirstOrDefault(a => a.Key == "PropertyName");
            if (namedArg.Value.Value is string val && !string.IsNullOrWhiteSpace(val))
                return val;
        }
        return prop.Name;
    }

    private static IEnumerable<IPropertySymbol> GetComProperties(INamedTypeSymbol type, INamedTypeSymbol comIgnoreAttr)
    {
        return type.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p =>
                p.DeclaredAccessibility == Accessibility.Public &&
                !p.IsStatic &&
                !p.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, comIgnoreAttr))
            );
    }


    // Gibt z.B. "IComAddress" zurück für eine Com-Referenz, sonst normalen TypeName
    private static string GetComPropertyType(
        IPropertySymbol prop,
        Dictionary<string, INamedTypeSymbol> comTypes,
        INamedTypeSymbol autoGenAttr,
        bool asInterface)
    {
        var propType = prop.Type;
        string typeString;

        // NEU: Nullable-Handling
        bool isNullable = false;
        ITypeSymbol underlyingType = propType;

        if (propType is INamedTypeSymbol nts &&
            nts.IsGenericType &&
            nts.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T)
        {
            isNullable = true;
            underlyingType = nts.TypeArguments[0];
        }

        if (IsComEnumType(underlyingType, comTypes))
        {
            // Enum: immer der COM-Enum-Name!
            var comType = comTypes[underlyingType.ToDisplayString()];
            typeString = GetComClassName(comType, autoGenAttr, false);
        }
        else if (IsComType(underlyingType, comTypes))
        {
            var comType = comTypes[underlyingType.ToDisplayString()];
            typeString = GetComClassName(comType, autoGenAttr, asInterface);
        }
        else
        {
            typeString = underlyingType.ToDisplayString();
        }

        if (isNullable && !typeString.EndsWith("?"))
            typeString += "?";
        return typeString;
    }


    private static bool IsNullable(IPropertySymbol prop)
    {
        return prop.NullableAnnotation == NullableAnnotation.Annotated
               || (prop.Type is INamedTypeSymbol nts && nts.IsGenericType && nts.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T);
    }




    private static bool IsComType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
    {
        return comTypes.ContainsKey(type.ToDisplayString());
    }
}
