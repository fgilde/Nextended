using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Nextended.Core.Attributes;
using Nextended.CodeGen.Config;
using Nextended.CodeGen.Helper;
using Nextended.Core.Enums;

namespace Nextended.CodeGen.Generators.DtoGeneration;

public class DtoGenerationSymbols
{
    public INamedTypeSymbol? AutoGenerateDto, Ignore, PropertySetting;
    public DtoGenerationConfig Config { get; private set; } = null!;

    internal static ITypeSymbol NormalizeForLookup(ITypeSymbol type)
    {
        // Nullable<T> -> T
        type = type.UnwrapNullableTypeSymbol(); // RoslynHelper

        // Referenz-Nullability "?" entfernen
        if (type.NullableAnnotation == NullableAnnotation.Annotated)
            type = type.WithNullableAnnotation(NullableAnnotation.None);

        return type;
    }

    public static IEnumerable<IPropertySymbol> GetDtoPropertiesDeep(
        INamedTypeSymbol type,
        INamedTypeSymbol? ignoreAttr)
    {
        var seen = new HashSet<string>(StringComparer.Ordinal);
        for (var t = type; t != null; t = t.BaseType)
        {
            foreach (var p in t.GetMembers().OfType<IPropertySymbol>())
            {
                if (p.DeclaredAccessibility != Accessibility.Public || p.IsStatic) continue;
                if (ignoreAttr != null && p.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, ignoreAttr))) continue;
                if (seen.Add(p.Name)) yield return p;
            }
        }
    }

    public static DtoGenerationSymbols Collect(Compilation c, DtoGenerationConfig config) => new()
    {
        AutoGenerateDto = c.GetTypeByMetadataName(typeof(AutoGenerateDtoAttribute).FullName!),
        Ignore = c.GetTypeByMetadataName(typeof(IgnoreOnGenerationAttribute).FullName!),
        PropertySetting = c.GetTypeByMetadataName(typeof(GenerationPropertySettingAttribute).FullName!),
        Config = config
    };

    public List<INamedTypeSymbol> FindTypesWithAttribute(Compilation compilation)
    {
        return AutoGenerateDto != null
            ? FindTypesWithAttributeFromAllAssemblies(compilation, AutoGenerateDto)
            : new List<INamedTypeSymbol>();
    }

    public static List<INamedTypeSymbol> FindTypesWithAttributeFromAllAssemblies(
        Compilation compilation, params INamedTypeSymbol[] attributeTypes)
    {
        static IEnumerable<INamedTypeSymbol> FindAllTypes(INamespaceSymbol ns)
        {
            foreach (var member in ns.GetMembers())
            {
                if (member is INamespaceSymbol childNs)
                {
                    foreach (var t in FindAllTypes(childNs))
                        yield return t;
                }
                else if (member is INamedTypeSymbol t)
                {
                    yield return t;
                }
            }
        }

        static bool IsAttributeOrDerived(INamedTypeSymbol? attrClass, INamedTypeSymbol expectedBase)
        {
            while (attrClass != null)
            {
                if (SymbolEqualityComparer.Default.Equals(attrClass, expectedBase))
                    return true;
                attrClass = attrClass.BaseType;
            }
            return false;
        }

        var allTypes = FindAllTypes(compilation.GlobalNamespace).ToList();

        var attributedTypes = allTypes
            .Where(symbol => symbol.GetAttributes().Any(a =>
                attributeTypes.Any(attr => IsAttributeOrDerived(a.AttributeClass, attr))))
            .ToList();

        // Neue Liste, damit keine Duplikate und übersichtlich!
        var result = new HashSet<INamedTypeSymbol>(attributedTypes, SymbolEqualityComparer.Default);

        // Abgeleitete Typen finden (nur falls AutoGenerateDerived)
        foreach (var baseType in attributedTypes)
        {
            var autoAttr = baseType.GetAttributeInstance<AutoGenerateDtoAttribute>(attributeTypes[0]);
            if (autoAttr?.AutoGenerateDerived == true)
            {
                foreach (var t in allTypes.Where(t => t.TypeKind == TypeKind.Class))
                {
                    var curr = t.BaseType;
                    while (curr != null)
                    {
                        // WICHTIG: bei Generics immer OriginalDefinition vergleichen
                        var currDef = (curr as INamedTypeSymbol)?.OriginalDefinition ?? curr;
                        var baseDef = (baseType as INamedTypeSymbol)?.OriginalDefinition ?? baseType;

                        if (SymbolEqualityComparer.Default.Equals(currDef, baseDef))
                        {
                            result.Add(t);
                            break;
                        }
                        curr = curr.BaseType;
                    }
                }
            }
        }

        return result.ToList();
    }

    public static string GetDtoClassName(ITypeSymbol type, AutoGenerateDtoAttribute? attr, bool asInterface)
    {
        var main = !string.IsNullOrEmpty(attr?.GeneratedClassName) ? attr.GeneratedClassName : type.Name;
        int idx = main.IndexOf('`');
        if (idx >= 0) main = main.Substring(0, idx);
        var prefix = attr?.Prefix ?? string.Empty;
        var suffix = attr?.Suffix ?? string.Empty;
        return $"{(asInterface ? "I" : "")}{prefix}{main}{suffix}";
    }

    public static string GetDtoPropertyName(IPropertySymbol prop, GenerationPropertySettingAttribute? info)
        => !string.IsNullOrEmpty(info?.PropertyName) ? info.PropertyName : prop.Name;

    public static string GetToDtoMethodName(ISymbol type, AutoGenerateDtoAttribute? attr)
    {
        if (attr?.ToDtoMethodName != null && !string.IsNullOrWhiteSpace(attr.ToDtoMethodName))
            return attr.ToDtoMethodName;
        return $"To{attr?.Prefix}{attr?.Suffix}";
    }

    public static string GetToSourceMethodName(ISymbol type, AutoGenerateDtoAttribute? attr)
    {
        if (attr?.ToSourceMethodName != null && !string.IsNullOrWhiteSpace(attr.ToSourceMethodName))
            return attr.ToSourceMethodName;
        return "ToNet";
    }

    public static IEnumerable<IPropertySymbol> GetDtoProperties(INamedTypeSymbol type, INamedTypeSymbol? ignoreAttr)
        => type.GetMembers().OfType<IPropertySymbol>().Where(p =>
            p.DeclaredAccessibility == Accessibility.Public &&
            !p.IsStatic &&
            (ignoreAttr == null || !p.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, ignoreAttr)))
        );

    /// <summary>
    /// String-Repräsentation des DTO-Propertytyps für Interface/Klasse.
    /// - Skalar (DTO/Enum): nur Typname (ohne Namespace), Nullability exakt
    /// - Nullable&lt;T&gt;: wie Skalar (nur Name), + "?"
    /// - Arrays/Generics: vollständiger Typstring mit vollqualifizierten inneren DTO/ENUMs; "?" nur auf Gesamtstruktur
    /// - Nicht-DTO: Originaltyp (CSharpErrorMessageFormat)
    /// </summary>
    public static string GetDtoPropertyType(
        IPropertySymbol prop,
        Dictionary<string, INamedTypeSymbol> comTypes,
        DtoGenerationSymbols symbols,
        bool asInterface)
    {
        var t = prop.Type;

        // 1) Nullable<T> (z. B. Enums)
        if (IsNullableValueType(t, out var underlying))
        {
            var core = NormalizeForLookup(underlying);

            if (IsDtoEnumType(core, comTypes))
            {
                var targetClass = comTypes[core.ToDisplayString()];
                var cfg = targetClass.ClassCfg(symbols);
                var name = GetDtoClassName(targetClass, cfg, /*asInterface*/ false); // nur Name!
                return name + "?";
            }

            if (IsDtoType(core, comTypes))
            {
                var targetClass = comTypes[core.ToDisplayString()];
                var cfg = targetClass.ClassCfg(symbols);
                var name = GetDtoClassName(targetClass, cfg, asInterface); // nur Name!
                return name + "?";
            }

            // nicht-DTO Nullable<T> -> "T?" als Kurzform, wenn möglich
            var shortName = core.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat);
            return shortName + "?";
        }

        // 2) Arrays & Generics (außer Nullable<T>)
        if (t is IArrayTypeSymbol || (t is INamedTypeSymbol ng && ng.IsGenericType))
        {
            // kompletter Typstring inkl. innerer Namespaces
            var core = BuildTypeStringWithDtoSubstitution(t, comTypes, symbols, insideGeneric: false);

            // Property-Nullability für die gesamte generische Struktur berücksichtigen
            if (prop.IsNullable() && !core.EndsWith("?"))
                core += "?";

            return core;
        }

        // 3) Skalar (nicht Nullable<T>)
        var sNorm = NormalizeForLookup(t);
        if (IsDtoEnumType(sNorm, comTypes))
        {
            var targetClass = comTypes[sNorm.ToDisplayString()];
            var cfg = targetClass.ClassCfg(symbols);
            var name = GetDtoClassName(targetClass, cfg, false); // nur Name!
            return prop.IsNullable() && !name.EndsWith("?") ? name + "?" : name;
        }

        if (IsDtoType(sNorm, comTypes))
        {
            var targetClass = comTypes[sNorm.ToDisplayString()];
            var cfg = targetClass.ClassCfg(symbols);
            var name = GetDtoClassName(targetClass, cfg, asInterface); // nur Name!
            return prop.IsNullable() && !name.EndsWith("?") ? name + "?" : name;
        }

        // 4) Nicht-DTO/-Enum
        var plain = t.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat);
        if (prop.IsNullable() && !plain.EndsWith("?")) plain += "?";
        return plain;
    }

    public static IEnumerable<string> GetReferencedNamespaces(
        INamedTypeSymbol type,
        Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        var result = new HashSet<string>();
        foreach (var p in GetDtoProperties(type, null))
        {
            foreach (var inner in WalkTypeTree(p.Type))
            {
                var key = inner.ToDisplayString();
                if (dtoTypeDict.ContainsKey(key))
                {
                    var ns = dtoTypeDict[key].ContainingNamespace?.ToDisplayString();
                    if (!string.IsNullOrWhiteSpace(ns))
                        result.Add(ns);
                }
            }
        }
        return result;
    }

    /// <summary>
    /// Namespace-Prefix für die Property-Deklaration (z. B. "MyGeneration."), nur für skalare DTO/Enum-Typen.
    /// Für Generics/Arrays leer, da inner bereits vollqualifiziert sind.
    /// </summary>
    public string GetNamespaceForProperty(IPropertySymbol property, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        var t = property.Type;

        // Arrays & Generics (außer Nullable<T>) -> KEIN Prefix, da inner schon vollqualifiziert sind
        if (t is IArrayTypeSymbol) return string.Empty;
        if (t is INamedTypeSymbol ng && ng.IsGenericType && ng.ConstructedFrom?.SpecialType != SpecialType.System_Nullable_T)
            return string.Empty;

        // Nullable<T> -> underlying Typ für Namespace-Entscheidung
        if (IsNullableValueType(t, out var underlying))
            t = underlying;

        var core = NormalizeForLookup(t);

        if (!(IsDtoType(core, dtoTypeDict) || IsDtoEnumType(core, dtoTypeDict)))
            return string.Empty;

        return GetNamespacePrefixString(GetClassCfgForType(core, dtoTypeDict));
    }

    // ---- Mapping-spezifische Utilities (zentralisiert) ----

    /// <summary>
    /// Baut einen vollständigen Zieltypstring für Mapping-Aufrufe (MapTo&lt;T&gt;).
    /// - toNet == true  -> Blätter vollqualifiziert (.NET-Ziel)
    /// - toNet == false -> Blätter als vollqualifizierte DTO-/ENUM-Typen (Klassenform)
    /// </summary>
    public static string BuildMappingTargetTypeString(
        ITypeSymbol type,
        bool toNet,
        Dictionary<string, INamedTypeSymbol> comTypes,
        DtoGenerationSymbols symbols)
    {
        // Arrays
        if (type is IArrayTypeSymbol ats)
            return BuildMappingTargetTypeString(ats.ElementType, toNet, comTypes, symbols) + "[]";

        // Generische Typen: Basistyp je Richtung (DTO vs .NET) wählen
        if (type is INamedTypeSymbol nts && nts.IsGenericType)
        {
            var baseName = toNet
                ? nts.ConstructedFrom.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat)
                : GetQualifiedDtoTypeName(nts.ConstructedFrom, comTypes, symbols, asInterfaceForNonGeneric: false);

            baseName = baseName.Split('<')[0];

            var args = nts.TypeArguments
                .Select(a => BuildMappingTargetTypeString(a, toNet, comTypes, symbols));

            return $"{baseName}<{string.Join(", ", args)}>";
        }

        // Blätter:
        // - toNet: vollqualifizierter .NET-Typ
        // - sonst: vollqualifizierter DTO-/ENUM-Typ in Klassenform
        if (toNet)
            return type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        return GetQualifiedDtoTypeName(type, comTypes, symbols, asInterfaceForNonGeneric: false);
    }


    /// <summary>
    /// Einfache Mengen-Typen (ohne Dictionary).
    /// </summary>
    public static bool IsSimpleEnumerableType(INamedTypeSymbol nts)
    {
        var gen = nts.ConstructedFrom.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat);
        return gen.StartsWith("System.Collections.Generic.IEnumerable<")
               || gen.StartsWith("System.Collections.Generic.ICollection<")
               || gen.StartsWith("System.Collections.Generic.IList<")
               || gen.StartsWith("System.Collections.Generic.List<")
               || gen.StartsWith("System.Collections.Generic.IReadOnlyList<")
               || gen.StartsWith("System.Collections.Generic.IReadOnlyCollection<")
               || gen.StartsWith("System.Collections.Generic.HashSet<");
    }

    public static bool IsDictionaryType(INamedTypeSymbol nts)
    {
        var gen = nts.ConstructedFrom.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat);
        return gen.StartsWith("System.Collections.Generic.Dictionary<")
               || gen.StartsWith("System.Collections.Generic.IDictionary<");
    }

    /// <summary>
    /// Hilfsroutine für Cast-Typnamen in expliziten Interface-Settern (Suffix '?' entfernen).
    /// </summary>
    public static string TrimNullableSuffix(string typeName)
        => !string.IsNullOrEmpty(typeName) && typeName.EndsWith("?")
            ? typeName.Substring(0, typeName.Length - 1)
            : typeName;

    // ---- Ende: Mapping-spezifische Utilities ----

    // DtoGenerationSymbols.cs
    public static InterfaceProperty ResolveInterfaceAccess(
        IPropertySymbol prop,
        AutoGenerateDtoAttribute classAttr,
        DtoGenerationSymbols symbols)
    {
        var propAttr = prop.PropertyCfg(symbols);
        // EXAKT das gleiche Fallback wie in der Interface-Generierung:
        var access = propAttr?.InterfaceAccess ?? classAttr.DefaultPropertyInterfaceAccess;
        return access;
    }

    public static bool IsDtoType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
        => comTypes.ContainsKey(NormalizeForLookup(type).ToDisplayString());

    public static bool IsDtoEnumType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
    {
        if (type is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nts)
            type = nts.TypeArguments[0];
        return comTypes.TryGetValue(type.ToDisplayString(), out var t) && t.TypeKind == TypeKind.Enum;
    }

    public static string[] GetUsings(INamedTypeSymbol type, Dictionary<string, INamedTypeSymbol> dtoTypeDict,
        AutoGenerateDtoAttribute autoGenAttr, DtoGenerationConfig cfg)
    {
        return GetUsings(new[] { type }, dtoTypeDict, autoGenAttr, cfg);
    }

    public static string[] GetUsings(IEnumerable<INamedTypeSymbol> types, Dictionary<string, INamedTypeSymbol> dtoTypeDict,
        AutoGenerateDtoAttribute? autoGenAttr, DtoGenerationConfig cfg)
    {
        // TODO: Setting check from AutoGenerateDtoAttribute
        var usings = new HashSet<string>(autoGenAttr?.Usings ?? cfg.Usings ?? Enumerable.Empty<string>())
        {
            "System",
        };
        if (autoGenAttr?.IsComCompatible ?? true)
            usings.Add("System.Runtime.InteropServices");
        foreach (var t in types)
        {
            if (autoGenAttr?.AddContainingNamespaceUsings == true || cfg?.AddContainingNamespaceUsings == true)
                usings.Add(t.ContainingNamespace.ToDisplayString());
            if (autoGenAttr?.AddReferencedNamespacesUsings == true || cfg?.AddReferencedNamespacesUsings == true)
                usings.UnionWith(GetReferencedNamespaces(t, dtoTypeDict));
        }
        return usings.ToArray();
    }

    public static string RegionNameFor(INamedTypeSymbol type, AutoGenerateDtoAttribute autoGenAttr)
    {
        return $"{(autoGenAttr.IsComCompatible == true ? "COM" : "Dto")} class for {type.Name}";
    }

    public static string GetGenericTypeParameters(ITypeSymbol type)
    {
        return type is INamedTypeSymbol named ? GetGenericTypeParameters(named) : "";
    }

    public static string GetGenericTypeParameters(INamedTypeSymbol type)
    {
        if (!type.IsGenericType) return "";
        return "<" + string.Join(", ", type.TypeParameters.Select(tp => tp.Name)) + ">";
    }

    public string GetBaseTypeString(INamedTypeSymbol type, Dictionary<string, INamedTypeSymbol> dtoTypeDict, bool asInterface)
    {
        return GetBaseTypeString(type, type.ClassCfg(this), dtoTypeDict, asInterface);
    }

    public string GetBaseTypeString(INamedTypeSymbol type, AutoGenerateDtoAttribute classAttr, Dictionary<string, INamedTypeSymbol> dtoTypeDict, bool asInterface)
    {
        return GetBaseTypeString(type, classAttr.Interfaces, dtoTypeDict, asInterface);
    }

    public string GetBaseTypeString(INamedTypeSymbol type, string[]? interfaces, Dictionary<string, INamedTypeSymbol> dtoTypeDict, bool asInterface)
    {
        var baseTypeStr = interfaces?.Any() ?? false ? $":{string.Join(", ", interfaces)}" : "";
        return GetBaseTypeString(type, baseTypeStr, dtoTypeDict, asInterface);
    }

    private static bool IsNullableValueType(ITypeSymbol t, out ITypeSymbol underlying)
    {
        if (t is INamedTypeSymbol ng && ng.ConstructedFrom?.SpecialType == SpecialType.System_Nullable_T && ng.TypeArguments.Length == 1)
        {
            underlying = ng.TypeArguments[0];
            return true;
        }
        underlying = null;
        return false;
    }

    public string GetBaseTypeString(INamedTypeSymbol type, string baseTypeStr, Dictionary<string, INamedTypeSymbol> dtoTypeDict, bool asInterface)
    {
        var baseType = type.BaseType;
        if (baseType != null)
        {
            // Versuche erst den konstruierten Typ, dann die Open-Definition im Dict zu finden
            INamedTypeSymbol? baseTypeSymbol = null;
            var keyConstructed = baseType.ToDisplayString();
            var keyOpen = (baseType.OriginalDefinition as INamedTypeSymbol)?.ToDisplayString();

            if (!string.IsNullOrEmpty(keyConstructed) && dtoTypeDict.TryGetValue(keyConstructed, out var tmp1))
                baseTypeSymbol = tmp1;
            else if (!string.IsNullOrEmpty(keyOpen) && dtoTypeDict.TryGetValue(keyOpen, out var tmp2))
                baseTypeSymbol = tmp2;

            if (baseTypeSymbol != null)
            {
                var baseTypeAttr = baseTypeSymbol.ClassCfg(this);
                if (baseTypeAttr != null)
                {
                    // Namespace des Basis-DTO ermitteln
                    var ns = GetNamespacePrefixString(baseTypeAttr);

                    // DTO-Namen der Basis (ohne Generics)
                    var baseDtoName = GetDtoClassName(baseTypeSymbol, baseTypeAttr, asInterface);

                    // Generische Argumente vom KONSTRUIERTEN BaseType mitnehmen (z. B. <T> oder <int>)
                    string baseGenericArgs = "";
                    if (baseType.IsGenericType)
                    {
                        if (baseType.TypeArguments.Length > 0)
                        {
                            baseGenericArgs = "<" + string.Join(", ",
                                baseType.TypeArguments.Select(a => a.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat))) + ">";
                        }
                        else
                        {
                            // Fallback: reine Typparameter der Basisdefinition
                            baseGenericArgs = GetGenericTypeParameters(baseType);
                        }
                    }

                    var baseInterfaceName = ns + baseDtoName + baseGenericArgs;
                    if (string.IsNullOrWhiteSpace(baseTypeStr))
                        baseTypeStr = $": {baseInterfaceName}";
                    else
                        baseTypeStr += $", {baseInterfaceName}";
                }
            }
        }

        return baseTypeStr;
    }

    internal string Namespace(INamedTypeSymbol? type, AutoGenerateDtoAttribute? cfg = null)
    {
        cfg ??= type?.ClassCfg(this);
        var ns = GetNamespacePrefixString(cfg);
        if (!string.IsNullOrWhiteSpace(ns))
            return ns.Substring(0, ns.Length - 1);
        if (!string.IsNullOrWhiteSpace(Config.Namespace))
            return Config.Namespace;
        if (type != null)
            return type.ContainingNamespace.ToDisplayString() + ".Generated";
        return "Nextended.CodeGen.Generated";
    }

    public string GetNamespacePrefixString(AutoGenerateDtoAttribute classCfg)
    {
        return GetNamespacePrefixString(classCfg?.Namespace);
    }

    public string GetNamespacePrefixString(string @namespace)
    {
        var result = @namespace;
        return string.IsNullOrWhiteSpace(result) ? string.Empty : $"{result}.";
    }

    public AutoGenerateDtoAttribute? GetClassCfgForType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        type = NormalizeForLookup(type);
        return dtoTypeDict.ContainsKey(type.ToDisplayString())
            ? dtoTypeDict[type.ToDisplayString()].ClassCfg(this)
            : null;
    }

    public bool PropertyInBaseType(IPropertySymbol prop, INamedTypeSymbol? baseType, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        while (baseType != null)
        {
            // sowohl konstruierte als auch offene Basis im Dict akzeptieren
            var keyConstructed = baseType.ToDisplayString();
            var keyOpen = (baseType.OriginalDefinition as INamedTypeSymbol)?.ToDisplayString();

            INamedTypeSymbol? dtoBaseSymbol = null;
            if (!string.IsNullOrEmpty(keyConstructed) && dtoTypeDict.TryGetValue(keyConstructed, out var tmp1))
                dtoBaseSymbol = tmp1;
            else if (!string.IsNullOrEmpty(keyOpen) && dtoTypeDict.TryGetValue(keyOpen, out var tmp2))
                dtoBaseSymbol = tmp2;

            if (dtoBaseSymbol != null)
            {
                var baseProps = GetDtoProperties(dtoBaseSymbol, Ignore);
                if (baseProps.Any(bp => bp.Name == prop.Name))
                    return true;
            }

            baseType = baseType.BaseType;
        }
        return false;
    }

    public static bool ContainsDtoTypeRecursive(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
        => WalkTypeTree(type).Any(t => IsDtoType(t, comTypes) || IsDtoEnumType(t, comTypes));

    private static string BuildTypeStringWithDtoSubstitution(
        ITypeSymbol type,
        Dictionary<string, INamedTypeSymbol> comTypes,
        DtoGenerationSymbols symbols,
        bool insideGeneric)
    {
        // Arrays
        if (type is IArrayTypeSymbol ats)
        {
            var elem = BuildTypeStringWithDtoSubstitution(ats.ElementType, comTypes, symbols, true);
            return elem + "[]";
        }

        // Generics (außer Nullable<T>, das behandelt GetDtoPropertyType separat)
        if (type is INamedTypeSymbol nts && nts.IsGenericType
                                         && nts.ConstructedFrom?.SpecialType != SpecialType.System_Nullable_T)
        {
            // Basistyp ebenfalls in DTO-Form umschalten
            var baseName = GetQualifiedDtoTypeName(nts.ConstructedFrom, comTypes, symbols, asInterfaceForNonGeneric: false);
            baseName = baseName.Split('<')[0];

            // Typargumente rekursiv in DTO-Form bringen
            var args = nts.TypeArguments
                .Select(a => BuildTypeStringWithDtoSubstitution(a, comTypes, symbols, true));

            var s = $"{baseName}<{string.Join(", ", args)}>";

            // Kein '?' innerhalb generischer Argumente
            if (insideGeneric)
                return s;

            // Referenz-Nullability nur auf oberster Ebene berücksichtigen
            if (type.NullableAnnotation == NullableAnnotation.Annotated && !s.EndsWith("?"))
                s += "?";

            return s;
        }

        // Skalar (oder Nullable-Untertyp wird separat gehandhabt)
        var core = NormalizeForLookup(type);
        var scalar = GetQualifiedDtoTypeName(core, comTypes, symbols, asInterfaceForNonGeneric: false);

        // Kein '?' innerhalb generischer Argumente
        if (insideGeneric)
            return scalar;

        // Referenz-Nullability nur auf oberster Ebene berücksichtigen
        if (type.NullableAnnotation == NullableAnnotation.Annotated && !scalar.EndsWith("?"))
            scalar += "?";

        return scalar;
    }


    public static string GetQualifiedDtoTypeName(
        ITypeSymbol type,
        Dictionary<string, INamedTypeSymbol> comTypes,
        DtoGenerationSymbols symbols,
        bool asInterfaceForNonGeneric)
    {
        type = NormalizeForLookup(type);

        if (IsDtoEnumType(type, comTypes))
        {
            var targetClass = comTypes[type.ToDisplayString()];
            var cfg = targetClass.ClassCfg(symbols);
            var name = GetDtoClassName(targetClass, cfg, false);
            var ns = symbols.GetNamespacePrefixString(cfg);
            return $"{ns}{name}";
        }

        if (IsDtoType(type, comTypes))
        {
            var targetClass = comTypes[type.ToDisplayString()];
            var cfg = targetClass.ClassCfg(symbols);
            var name = GetDtoClassName(targetClass, cfg, asInterfaceForNonGeneric);
            var ns = symbols.GetNamespacePrefixString(cfg);
            return $"{ns}{name}";
        }

        return type.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat);
    }

    static IEnumerable<ITypeSymbol> WalkTypeTree(ITypeSymbol type)
    {
        type = NormalizeForLookup(type);
        yield return type;

        if (type is IArrayTypeSymbol ats)
        {
            foreach (var t in WalkTypeTree(ats.ElementType))
                yield return t;
        }
        else if (type is INamedTypeSymbol nts && nts.IsGenericType)
        {
            foreach (var ta in nts.TypeArguments)
                foreach (var t in WalkTypeTree(ta))
                    yield return t;
        }
    }
}
