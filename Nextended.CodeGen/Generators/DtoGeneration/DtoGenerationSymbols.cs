using Microsoft.CodeAnalysis;
using Nextended.CodeGen.Attributes;
using Nextended.CodeGen.Config;
using Nextended.CodeGen.Helper;

namespace Nextended.CodeGen.Generators.DtoGeneration;

public class DtoGenerationSymbols
{
    public INamedTypeSymbol? AutoGenerateDto, Ignore, PropertySetting;
    public DtoGenerationConfig Config { get; private set; }

    public static DtoGenerationSymbols Collect(Compilation c, DtoGenerationConfig config) => new()
    {
        AutoGenerateDto = c.GetTypeByMetadataName(typeof(AutoGenerateDtoAttribute).FullName!),
        Ignore = c.GetTypeByMetadataName(typeof(IgnoreOnGenerationAttribute).FullName!),
        PropertySetting = c.GetTypeByMetadataName(typeof(GenerationPropertySettingAttribute).FullName!),
        Config = config
    };

    public List<INamedTypeSymbol> FindTypesWithAttribute(Compilation compilation)
    {
        return AutoGenerateDto != null
            ? FindTypesWithAttributeFromAllAssemblies(compilation, AutoGenerateDto)
            : new List<INamedTypeSymbol>();
    }

    public static List<INamedTypeSymbol> FindTypesWithAttributeFromAllAssemblies(
        Compilation compilation, params INamedTypeSymbol[] attributeTypes)
    {
        static IEnumerable<INamedTypeSymbol> FindAllTypes(INamespaceSymbol ns)
        {
            foreach (var member in ns.GetMembers())
            {
                if (member is INamespaceSymbol childNs)
                {
                    foreach (var t in FindAllTypes(childNs))
                        yield return t;
                }
                else if (member is INamedTypeSymbol t)
                {
                    yield return t;
                }
            }
        }

        static bool IsAttributeOrDerived(INamedTypeSymbol? attrClass, INamedTypeSymbol expectedBase)
        {
            while (attrClass != null)
            {
                if (SymbolEqualityComparer.Default.Equals(attrClass, expectedBase))
                    return true;
                attrClass = attrClass.BaseType;
            }
            return false;
        }

        var allTypes = FindAllTypes(compilation.GlobalNamespace);

        return allTypes
            .Where(symbol => symbol.GetAttributes().Any(a =>
                attributeTypes.Any(attr => IsAttributeOrDerived(a.AttributeClass, attr))))
            .ToList();
    }

    public static string GetDtoClassName(ITypeSymbol type, AutoGenerateDtoAttribute? attr, bool asInterface)
    {
        var main = !string.IsNullOrEmpty(attr?.GeneratedClassName) ? attr.GeneratedClassName : type.Name;
        int idx = main.IndexOf('`');
        if (idx >= 0) main = main.Substring(0, idx);
        var prefix = attr?.Prefix ?? string.Empty;
        var suffix = attr?.Suffix ?? string.Empty;
        return $"{(asInterface ? "I" : "")}{prefix}{main}{suffix}";
    }

    public static string GetDtoPropertyName(IPropertySymbol prop, GenerationPropertySettingAttribute? info)
        => !string.IsNullOrEmpty(info?.PropertyName) ? info.PropertyName : prop.Name;

    public static string GetToDtoMethodName(ISymbol type, AutoGenerateDtoAttribute? attr)
    {
        if (attr?.ToDtoMethodName != null && !string.IsNullOrWhiteSpace(attr.ToDtoMethodName))
            return attr.ToDtoMethodName;
        return $"To{attr?.Prefix}{attr?.Suffix}";
    }

    public static string GetToSourceMethodName(ISymbol type, AutoGenerateDtoAttribute? attr)
    {
        if (attr?.ToSourceMethodName != null && !string.IsNullOrWhiteSpace(attr.ToSourceMethodName))
            return attr.ToSourceMethodName;
        return "ToNet";
    }

    public static IEnumerable<IPropertySymbol> GetDtoProperties(INamedTypeSymbol type, INamedTypeSymbol? ignoreAttr)
        => type.GetMembers().OfType<IPropertySymbol>().Where(p =>
            p.DeclaredAccessibility == Accessibility.Public &&
            !p.IsStatic &&
            (ignoreAttr == null || !p.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, ignoreAttr)))
        );

    public static string GetDtoPropertyType(
        IPropertySymbol prop,
        Dictionary<string, INamedTypeSymbol> comTypes,
        DtoGenerationSymbols symbols,
        bool asInterface)
    {
        var propType = prop.Type;
        bool isNullable = false;
        ITypeSymbol underlyingType = propType;
        if (propType is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nts)
        {
            isNullable = true;
            underlyingType = nts.TypeArguments[0];
        }
        string typeString;
        if (IsDtoEnumType(underlyingType, comTypes))
        {
            var targetClass = comTypes[underlyingType.ToDisplayString()];
            var targetAttr = targetClass.ClassCfg(symbols);
            typeString = GetDtoClassName(targetClass, targetAttr, false);
        }
        else if (IsDtoType(underlyingType, comTypes))
        {
            var targetClass = comTypes[underlyingType.ToDisplayString()];
            var targetAttr = targetClass.ClassCfg(symbols);
            typeString = GetDtoClassName(targetClass, targetAttr, asInterface);
        }
        else
        {
            typeString = underlyingType.ToDisplayString();
        }
        if (isNullable && !typeString.EndsWith("?"))
            typeString += "?";
        return typeString;
    }

    public static bool IsDtoType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
        => comTypes.ContainsKey(type.ToDisplayString());

    public static bool IsDtoEnumType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
    {
        if (type is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nts)
            type = nts.TypeArguments[0];
        return comTypes.TryGetValue(type.ToDisplayString(), out var t) && t.TypeKind == TypeKind.Enum;
    }


    /// <summary>
    /// Liefert alle Namespaces, auf die Properties des Typs verweisen (für Usings).
    /// </summary>
    public static IEnumerable<string> GetReferencedNamespaces(
        INamedTypeSymbol type,
        Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        return GetDtoProperties(type, null)
            .Select(p => p.Type)
            .Where(t => comTypeDict.ContainsKey(t.ToDisplayString()))
            .Select(t => comTypeDict[t.ToDisplayString()].ContainingNamespace.ToDisplayString())
            .Where(ns => !string.IsNullOrWhiteSpace(ns));
    }

    public static string[] GetUsings(INamedTypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypeDict,
        AutoGenerateDtoAttribute autoGenAttr, DtoGenerationConfig cfg)
    {
        return GetUsings([type], comTypeDict, autoGenAttr, cfg);
    }

    public static string[] GetUsings(IEnumerable<INamedTypeSymbol> types, Dictionary<string, INamedTypeSymbol> comTypeDict, 
        AutoGenerateDtoAttribute? autoGenAttr, DtoGenerationConfig cfg )
    {
        // TODO: Setting check from AutoGenerateDtoAttribute
        var usings = new HashSet<string>(autoGenAttr?.Usings ?? cfg.Usings ?? Enumerable.Empty<string>())
        {
            "System",
        };
        if (autoGenAttr?.IsComCompatible ?? true)
            usings.Add("System.Runtime.InteropServices");
        foreach (var t in types)
        {
            if(autoGenAttr?.AddContainingNamespaceUsings == true || cfg?.AddContainingNamespaceUsings == true)
                usings.Add(t.ContainingNamespace.ToDisplayString());
            if(autoGenAttr?.AddReferencedNamespacesUsings == true || cfg?.AddReferencedNamespacesUsings == true)
                usings.UnionWith(GetReferencedNamespaces(t, comTypeDict));
        }
        return usings.ToArray();
    }

    public static string RegionNameFor(INamedTypeSymbol type, AutoGenerateDtoAttribute autoGenAttr)
    {
        return $"{(autoGenAttr.IsComCompatible == true ? "COM" : "Dto")} class for {type.Name}";
    }

    public static string GetGenericTypeParameters(ITypeSymbol type)
    {
       return type is INamedTypeSymbol named ? GetGenericTypeParameters(named) : "";
    }
    
    public static string GetGenericTypeParameters(INamedTypeSymbol type)
    {
        if (!type.IsGenericType) return "";
        return "<" + string.Join(", ", type.TypeParameters.Select(tp => tp.Name)) + ">";
    }

}
