using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Nextended.CodeGen.Config;
using Nextended.CodeGen.Contracts;
using Nextended.CodeGen.Helper;

namespace Nextended.CodeGen.Generators.DtoGeneration;

public class DtoGenerator : ISourceSubGenerator
{
    private DtoGenerationConfig _config = null!;
    public bool RequireConfig => false;

    public DtoGenerator()
    { }

    public DtoGenerator(DtoGenerationConfig config)
    {
        _config = config;
    }

    public IEnumerable<GeneratedFile> Execute(GenerationContext context)
    {
        _config = context.Config?.DtoGeneration ?? new DtoGenerationConfig();
        if (_config.DisableGeneration)
            return [];

        if (context.ExecutionContext.HasValue)
            return Execute(context.ExecutionContext.Value);

        if (context.Compilation is null)
            return [];

        return Execute(context.Compilation);
    }

    public IEnumerable<GeneratedFile> Execute(GeneratorExecutionContext context)
        => Execute(context.Compilation);

    public IEnumerable<GeneratedFile> Execute(Compilation compilation)
    {
        var symbols = DtoGenerationSymbols.Collect(compilation, _config);
        if (symbols.AutoGenerateDto == null)
            yield break;

        string[] allNs = [];
        var types = symbols.FindTypesWithAttribute(compilation);
        var generator = new DtoCodeGenerator(_config, symbols);

        if (_config.OneFilePerClass)
        {
            foreach (var type in types)
            {
                yield return generator.GenerateAllForType(type, types);
            }
        }
        else
        {
            var typesByNs = types.GroupBy(t => generator.Namespace(t));
            allNs = typesByNs.OrderBy(g => g.Key).Select(t => t.Key).Distinct().ToArray();

            foreach (var group in typesByNs)
            {
                var ns = group.Key;
                var dtoTypeDict = types.ToDictionary(t => t.ToDisplayString(), t => t);
                var res = generator.GenerateNamespaceFile(ns, group, dtoTypeDict);

                yield return new GeneratedFile(
                    res.FileName,
                    res.Namespace,
                    res.Content.InsertUsings(allNs),
                    res.OutputPath ?? _config?.OutputPath);
            }
        }

        if (generator.HasGuids)
        {
            yield return generator.GenerateComIdFile(types);
        }

        var mappingFiles = generator.GenerateMappingExtensions(types.ToList());
        foreach (var mappingFile in mappingFiles)
        {
            if (mappingFile != null)
            {
                yield return new GeneratedFile(
                    mappingFile.FileName,
                    mappingFile.Namespace,
                    mappingFile.Content.InsertUsings(allNs),
                    mappingFile.OutputPath ?? _config?.OutputPath);
            }
        }
    }
}
