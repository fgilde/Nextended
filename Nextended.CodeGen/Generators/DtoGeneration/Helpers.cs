using Microsoft.CodeAnalysis;
using Nextended.CodeGen.Attributes;
using Nextended.CodeGen.Config;
using Nextended.CodeGen.Helper;

namespace Nextended.CodeGen.Generators.DtoGeneration;

public static class Helpers
{

    public static string GetToComMethodName(INamedTypeSymbol type, INamedTypeSymbol autoGenAttr)
    {
        var info = type.GetAttributeInstance<AutoGenerateDtoAttribute>(autoGenAttr);
        if (!string.IsNullOrWhiteSpace(info.ToDtoMethodName))
            return info.ToDtoMethodName;
        return $"To{info.Prefix}{info.Suffix}";
    }

    public static string GetComClassName(INamedTypeSymbol type, INamedTypeSymbol autoGenAttr, bool asInterface)
    {
        var info = type.GetAttributeInstance<AutoGenerateDtoAttribute>(autoGenAttr);
        return GetComClassName(type, info, asInterface);
    }

    public static string GetComClassName(INamedTypeSymbol type, AutoGenerateDtoAttribute info, bool asInterface)
    {
        string main = !string.IsNullOrEmpty(info.GeneratedClassName) ? info.GeneratedClassName : type.Name;
        int idx = main.IndexOf('`');
        if (idx >= 0) main = main.Substring(0, idx);

        return $"{(asInterface ? "I" : "")}{info.Prefix}{main}{info.Suffix}";
    }

    public static string GetComPropertyName(IPropertySymbol prop, INamedTypeSymbol? settingAttr)
    {
        var info = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(settingAttr);
        return !string.IsNullOrEmpty(info?.PropertyName) ? info.PropertyName : prop.Name;
    }
    public static IEnumerable<IPropertySymbol> GetComProperties(INamedTypeSymbol type, INamedTypeSymbol? ignoreAttr)
        => type.GetMembers().OfType<IPropertySymbol>().Where(p =>
            p.DeclaredAccessibility == Accessibility.Public &&
            !p.IsStatic &&
            (ignoreAttr == null || !p.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, ignoreAttr)))
        );



    public static bool IsComType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
        => comTypes.ContainsKey(type.ToDisplayString());
    public static bool IsComEnumType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
    {
        if (type is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nts)
            type = nts.TypeArguments[0];
        return comTypes.TryGetValue(type.ToDisplayString(), out var t) && t.TypeKind == TypeKind.Enum;
    }
    public static string GetComPropertyType(IPropertySymbol prop, Dictionary<string, INamedTypeSymbol> comTypes, INamedTypeSymbol autoGenAttr, bool asInterface)
    {
        var propType = prop.Type;
        bool isNullable = false;
        ITypeSymbol underlyingType = propType;
        if (propType is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nts)
        {
            isNullable = true;
            underlyingType = nts.TypeArguments[0];
        }
        string typeString;
        if (IsComEnumType(underlyingType, comTypes))
            typeString = GetComClassName(comTypes[underlyingType.ToDisplayString()], autoGenAttr, false);
        else if (IsComType(underlyingType, comTypes))
            typeString = GetComClassName(comTypes[underlyingType.ToDisplayString()], autoGenAttr, asInterface);
        else
            typeString = underlyingType.ToDisplayString();
        if (isNullable && !typeString.EndsWith("?"))
            typeString += "?";
        return typeString;
    }
    public static (string Id, string ClassName) GetGuid(string className, Dictionary<string, string> comIds, DtoGenerationConfig cfg)
    {
        if (!comIds.TryGetValue(className, out var guid))
        {
            guid = Guid.NewGuid().ToString();
            comIds[className] = guid;
        }
        return (guid, $"{cfg.ComIdClassName}.{string.Format(cfg.ComIdClassPropertyFormat, className)}");
    }
}