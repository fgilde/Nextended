using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Nextended.Core.Attributes;
using Nextended.CodeGen.Config;
using Nextended.CodeGen.Helper;
using System.Text;
using Nextended.CodeGen.Contracts;
using Nextended.Core.Enums;

namespace Nextended.CodeGen.Generators.DtoGeneration;

public class DtoCodeGenerator
{
    private readonly DtoGenerationConfig _config;
    private readonly DtoGenerationSymbols _symbols;
    private readonly Dictionary<string, string> _comIds = new();

    public DtoCodeGenerator(DtoGenerationConfig config, DtoGenerationSymbols symbols)
    {
        _config = config;
        _symbols = symbols;
    }

    public bool HasGuids => _comIds.Any();

    /// <summary>
    /// Hauptmethode für die Dateierzeugung zu einem Typ (für OneFilePerClass = true).
    /// </summary>
    public GeneratedFile GenerateAllForType(INamedTypeSymbol type, List<INamedTypeSymbol> allTypes)
    {
        var autoGenAttr = type.ClassCfg(_symbols);
        var ns = Namespace(type);
        var dtoTypeDict = allTypes.ToDictionary(t => t.ToDisplayString(), t => t);

        var fileName = $"{DtoGenerationSymbols.GetDtoClassName(type, autoGenAttr, false)}.g.cs";
        var usings = DtoGenerationSymbols.GetUsings(type, dtoTypeDict, autoGenAttr, _config);

        var sb = new StringBuilder();

        sb.AppendFileHeader(fileName)
            .AppendUsings(usings);
        using (new NamespaceScope(sb, ns))
        {
            GenerateType(type, sb, autoGenAttr, dtoTypeDict);
        }

        return new GeneratedFile(fileName, ns, sb.ToString(), _config);
    }

    /// <summary>
    /// Methode für OneFilePerClass == false. Generiert eine Datei für alle Typen eines Namespaces.
    /// </summary>
    public GeneratedFile GenerateNamespaceFile(string ns, IEnumerable<INamedTypeSymbol> types, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        var usings = DtoGenerationSymbols.GetUsings(types, dtoTypeDict, null, _config);

        var sb = new StringBuilder();
        sb.AppendFileHeader()
            .AppendUsings(usings);

        using (new NamespaceScope(sb, ns))
        {
            foreach (var type in types)
            {
                var autoGenAttr = type.ClassCfg(_symbols);
                GenerateType(type, sb, autoGenAttr, dtoTypeDict);
            }
        }

        var fileName = $"{ns}.AllDtos.g.cs";
        return new GeneratedFile(fileName, ns, sb.ToString(), _config);
    }

    private void GenerateType(INamedTypeSymbol type, StringBuilder sb, AutoGenerateDtoAttribute autoGenAttr, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        var regionName = DtoGenerationSymbols.RegionNameFor(type, autoGenAttr);
        sb.OpenRegion(regionName, _config.CreateRegions);

        if (type.TypeKind == TypeKind.Enum)
        {
            sb.AppendLine(GenerateEnum(type, autoGenAttr, dtoTypeDict));
        }
        else
        {
            sb.AppendLine(GenerateInterface(type, autoGenAttr, dtoTypeDict, true));
            sb.AppendLine(GenerateClass(type, autoGenAttr, dtoTypeDict, true));
        }
        sb.CloseRegion(regionName, _config.CreateRegions);
    }

    private (string Result, bool ClassMapperUsed) GeneratePropertyMappingAssignment(IPropertySymbol prop, Dictionary<string, INamedTypeSymbol> dtoTypeDict, bool reverse)
    {
        var propAttr = prop.PropertyCfg(_symbols);

        var netPropName = prop.Name;
        var comPropName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
        var netPropType = prop.Type;

        var targetName = !reverse ? comPropName : netPropName;
        var sourceName = !reverse ? netPropName : comPropName;

        // Helper-Funktion: Liefert für reverse/source richtig den Target-Type für MapTo<>
        string GetTargetType(ITypeSymbol typeSymbol, bool reverseDir)
        {
            if (typeSymbol is INamedTypeSymbol nts)
            {
                // Für DTO-Ziel (forward mapping) -> Namespace aus dem AutoGen-Attribut verwenden
                var autoGenAttr = nts.ClassCfg(_symbols);

                if (!reverseDir)
                {
                    // Ziel ist DTO
                    var dtoName = DtoGenerationSymbols.GetDtoClassName(nts, autoGenAttr, /*withSuffix?*/ false);
                    var dtoNs = string.IsNullOrWhiteSpace(autoGenAttr?.Namespace) ? string.Empty : autoGenAttr.Namespace + ".";
                    var generics = DtoGenerationSymbols.GetGenericTypeParameters(nts);
                    return $"{dtoNs}{dtoName}{generics}";
                }

                // Reverse: Ziel ist das "Netto"-Modell -> vollqualifiziert (inkl. global::)
                return nts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            }

            // Fallback immer vollqualifiziert
            return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }

        if (DtoGenerationSymbols.IsDtoEnumType(netPropType, dtoTypeDict))
        {
            var enumType = netPropType.UnwrapNullableTypeSymbol();
            var targetClass = dtoTypeDict[enumType.ToDisplayString()];
            var targetAttr = targetClass.ClassCfg(_symbols);

            if (!targetAttr.GenerateMapping || (propAttr?.MapWithClassMapper ?? false))
            {
                var targetTypeString = GetTargetType(targetClass, reverse);
                return (prop.IsNullable()
                    ? $"\t\t\tresult.{targetName} = src.{sourceName}?.MapTo<{targetTypeString}>();"
                    : $"\t\t\tresult.{targetName} = src.{sourceName}.MapTo<{targetTypeString}>();", true);
            }

            var enumToComMethod = !reverse
                ? DtoGenerationSymbols.GetToDtoMethodName(targetClass, targetAttr)
                : DtoGenerationSymbols.GetToSourceMethodName(targetClass, targetAttr);

            return (prop.IsNullable()
                ? $"\t\t\tresult.{targetName} = src.{sourceName}?.{enumToComMethod}();"
                : $"\t\t\tresult.{targetName} = src.{sourceName}.{enumToComMethod}();", false);
        }

        if (DtoGenerationSymbols.IsDtoType(netPropType, dtoTypeDict))
        {
            var classType = netPropType.UnwrapNullableTypeSymbol();
            var targetClass = dtoTypeDict.ContainsKey(classType.ToDisplayString()) ? dtoTypeDict[classType.ToDisplayString()] : dtoTypeDict[DtoGenerationSymbols.NormalizeForLookup(classType).ToDisplayString()];
            var targetAttr = targetClass.ClassCfg(_symbols);

            if (!targetAttr.GenerateMapping || (propAttr?.MapWithClassMapper ?? false))
            {
                var targetTypeString = GetTargetType(targetClass, reverse);
                return (prop.IsNullable()
                    ? $"\t\t\tresult.{targetName} = src.{sourceName}?.MapTo<{targetTypeString}>();"
                    : $"\t\t\tresult.{targetName} = src.{sourceName}.MapTo<{targetTypeString}>();", true);
            }

            var propToComMethod = !reverse
                ? DtoGenerationSymbols.GetToDtoMethodName(targetClass, targetAttr)
                : DtoGenerationSymbols.GetToSourceMethodName(targetClass, targetAttr);

            return ($"\t\t\tresult.{targetName} = src.{sourceName}?.{propToComMethod}();", false);
        }
        return ($"\t\t\tresult.{targetName} = src.{sourceName};", false);
    }

    public GeneratedFile? GenerateMappingExtensions(List<INamedTypeSymbol> types)
    {
        bool atLeastOneGenerated = false;
        bool classMapperUsed = false;

        if (types == null || !types.Any())
            return null;

        // Konfig-Schalter (falls nicht vorhanden, Defaults/Backfills)
        var generateToForAbstract = _config?.GenerateToMethodsForAbstract ?? false;
        var generateFactoryForAbstract = _config?.GenerateFactoryOverloadsForAbstract ?? true;
        var alwaysGenerateFactory = _config?.AlwaysGenerateFactoryOverloads ?? false;

        var ns = Namespace(null);
        var sb = new StringBuilder();

        using (new ClassScope(sb, "MappingExtensions", ns))
        {
            var dtoTypeDict = types.ToDictionary(t => t.ToDisplayString(), t => t);

            // 1) Mapping-Methoden pro Typ
            foreach (var type in types)
            {
                var autoGenAttr = type.ClassCfg(_symbols);
                if (!autoGenAttr.GenerateMapping)
                    continue;

                atLeastOneGenerated = true;

                var toDtoMethod = DtoGenerationSymbols.GetToDtoMethodName(type, autoGenAttr);
                var toNetMethod = DtoGenerationSymbols.GetToSourceMethodName(type, autoGenAttr);
                var isEnum = type.TypeKind == TypeKind.Enum;
                var isAbstract = type.IsAbstract;
                var netTypeName = type.ToDisplayString();
                var dtoTypeName = DtoGenerationSymbols.GetDtoClassName(type, autoGenAttr, false);
                var comTypeNs = !string.IsNullOrWhiteSpace(autoGenAttr.Namespace) ? $"{autoGenAttr.Namespace}." : string.Empty;
                var genericParams = DtoGenerationSymbols.GetGenericTypeParameters(type); // "<T, T2>" oder ""
                var genericConstr = type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, dtoTypeDict);

                // === Enums: unverändert ===
                if (isEnum)
                {
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName}? {toDtoMethod}(this {netTypeName}? src) => src.HasValue ? ({comTypeNs}{dtoTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName}? {toNetMethod}(this {comTypeNs}{dtoTypeName}? src) => src.HasValue ? ({netTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName} {toDtoMethod}(this {netTypeName} src) => ({comTypeNs}{dtoTypeName})(int)src;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethod}(this {comTypeNs}{dtoTypeName} src) => ({netTypeName})(int)src;");
                    continue;
                }

                var comProps = DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore).ToList();
                var baseType = type.BaseType;

                // === AssignTo: Net -> DTO ===
                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static void AssignTo{genericParams}(this {netTypeName} src, {comTypeNs}{dtoTypeName}{genericParams} dest) {genericConstr}");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif (src == null || dest == null) return;");

                // Basismapping (Net -> DTO) via Base.AssignTo<...>(...)
                if (baseType != null && dtoTypeDict.TryGetValue(baseType.ToDisplayString(), out var baseTypeSymbol))
                {
                    var baseAutoGenAttr = baseTypeSymbol.ClassCfg(_symbols);
                    if (baseAutoGenAttr != null)
                    {
                        var baseDtoName = DtoGenerationSymbols.GetDtoClassName(baseType, baseAutoGenAttr, false); // ohne Generics
                        var baseNetName = baseType.ToDisplayString(); // inkl. Generics (z. B. CodeGenSample.Entities.GenericBaseClass<T>)

                        // Generische Argumente der Basis (z. B. "<T>" / "<int>")
                        string baseGenericArgs = "";
                        if (baseType.IsGenericType && baseType.TypeArguments.Length > 0)
                        {
                            baseGenericArgs = "<" + string.Join(", ",
                                baseType.TypeArguments.Select(a => a.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat))) + ">";
                        }
                        else
                        {
                            baseGenericArgs = DtoGenerationSymbols.GetGenericTypeParameters(baseType);
                        }

                        // AssignTo mit Methodengenerics aufrufen, falls vorhanden
                        var callGen = string.IsNullOrEmpty(genericParams) ? "" : genericParams;
                        sb.AppendLine($"\t\t\t(({baseNetName})src).AssignTo{callGen}(( {baseDtoName}{baseGenericArgs} )dest);");
                    }
                }

                // Eigene Properties (Net -> DTO)
                foreach (var prop in comProps.Where(prop => !_symbols.PropertyInBaseType(prop, type.BaseType, dtoTypeDict)))
                {
                    var m = GeneratePropertyMappingAssignment(prop, dtoTypeDict, reverse: false);
                    classMapperUsed = classMapperUsed || m.ClassMapperUsed;
                    sb.AppendLine(m.Result.Replace("result.", "dest."));
                }
                sb.AppendLine("\t\t}");

                // === AssignTo: DTO -> Net ===
                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static void AssignTo{genericParams}(this {comTypeNs}{dtoTypeName}{genericParams} src, {netTypeName} dest) {genericConstr}");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif (src == null || dest == null) return;");

                // Basismapping (DTO -> Net) via Base.AssignTo<...>(...)
                if (baseType != null && dtoTypeDict.TryGetValue(baseType.ToDisplayString(), out var baseTypeSymbol2))
                {
                    var baseAutoGenAttr2 = baseTypeSymbol2.ClassCfg(_symbols);
                    if (baseAutoGenAttr2 != null)
                    {
                        var baseDtoName = DtoGenerationSymbols.GetDtoClassName(baseType, baseAutoGenAttr2, false); // ohne Generics
                        var baseNetName = baseType.ToDisplayString(); // inkl. Generics

                        string baseGenericArgs = "";
                        if (baseType.IsGenericType && baseType.TypeArguments.Length > 0)
                        {
                            baseGenericArgs = "<" + string.Join(", ",
                                baseType.TypeArguments.Select(a => a.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat))) + ">";
                        }
                        else
                        {
                            baseGenericArgs = DtoGenerationSymbols.GetGenericTypeParameters(baseType);
                        }

                        var callGen = string.IsNullOrEmpty(genericParams) ? "" : genericParams;
                        sb.AppendLine($"\t\t\t(({baseDtoName}{baseGenericArgs})src).AssignTo{callGen}(( {baseNetName} )dest);");
                    }
                }

                // Eigene Properties (DTO -> Net)
                foreach (var prop in comProps.Where(prop => !_symbols.PropertyInBaseType(prop, type.BaseType, dtoTypeDict)))
                {
                    var m = GeneratePropertyMappingAssignment(prop, dtoTypeDict, reverse: true);
                    classMapperUsed = classMapperUsed || m.ClassMapperUsed;
                    sb.AppendLine(m.Result.Replace("result.", "dest."));
                }
                sb.AppendLine("\t\t}");

                // === ToDto / ToNet ===
                var canGenerateNewBasedTo = !isAbstract || generateToForAbstract;

                // ToDto: new + AssignTo
                if (canGenerateNewBasedTo)
                {
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName}{genericParams} {toDtoMethod}{genericParams}(this {netTypeName} src) {genericConstr}");
                    sb.AppendLine("\t\t{");
                    sb.AppendLine("\t\t\tif (src == null) return null;");
                    sb.AppendLine($"\t\t\tvar result = new {comTypeNs}{dtoTypeName}{genericParams}();");
                    sb.AppendLine("\t\t\tsrc.AssignTo{genericParams}(result);".Replace("{genericParams}", string.IsNullOrEmpty(genericParams) ? "" : genericParams));
                    sb.AppendLine("\t\t\treturn result;");
                    sb.AppendLine("\t\t}");
                }

                // ToNet: new + AssignTo
                if (canGenerateNewBasedTo)
                {
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethod}{genericParams}(this {comTypeNs}{dtoTypeName}{genericParams} src) {genericConstr}");
                    sb.AppendLine("\t\t{");
                    sb.AppendLine("\t\t\tif (src == null) return null;");
                    sb.AppendLine($"\t\t\tvar result = new {netTypeName}();");
                    sb.AppendLine("\t\t\tsrc.AssignTo{genericParams}(result);".Replace("{genericParams}", string.IsNullOrEmpty(genericParams) ? "" : genericParams));
                    sb.AppendLine("\t\t\treturn result;");
                    sb.AppendLine("\t\t}");
                }

                // === Factory-Overloads ===
                if ((isAbstract && generateFactoryForAbstract) || alwaysGenerateFactory)
                {
                    // Net -> DTO via Factory
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName}{genericParams} {toDtoMethod}{genericParams}(this {netTypeName} src, Func<{comTypeNs}{dtoTypeName}{genericParams}> factory) {genericConstr}");
                    sb.AppendLine("\t\t{");
                    sb.AppendLine("\t\t\tif (src == null) return null;");
                    sb.AppendLine("\t\t\tvar result = factory != null ? factory() : null;");
                    sb.AppendLine("\t\t\tif (result == null) return null;");
                    sb.AppendLine("\t\t\tsrc.AssignTo{genericParams}(result);".Replace("{genericParams}", string.IsNullOrEmpty(genericParams) ? "" : genericParams));
                    sb.AppendLine("\t\t\treturn result;");
                    sb.AppendLine("\t\t}");

                    // DTO -> Net via Factory
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethod}{genericParams}(this {comTypeNs}{dtoTypeName}{genericParams} src, Func<{netTypeName}> factory) {genericConstr}");
                    sb.AppendLine("\t\t{");
                    sb.AppendLine("\t\t\tif (src == null) return null;");
                    sb.AppendLine("\t\t\tvar result = factory != null ? factory() : null;");
                    sb.AppendLine("\t\t\tif (result == null) return null;");
                    sb.AppendLine("\t\t\tsrc.AssignTo{genericParams}(result);".Replace("{genericParams}", string.IsNullOrEmpty(genericParams) ? "" : genericParams));
                    sb.AppendLine("\t\t\treturn result;");
                    sb.AppendLine("\t\t}");
                }
            }

            sb.AppendLine("\t}");
        }

        if (!atLeastOneGenerated)
            return null;

        if (classMapperUsed)
            sb.Insert(0, "using Nextended.Core.Extensions;");

        return new GeneratedFile("MappingExtensions.g.cs", ns, sb.ToString(), _config?.MappingOutputPath ?? _config?.OutputPath);
    }




    //public GeneratedFile? GenerateMappingExtensionsLegacy(List<INamedTypeSymbol> types)
    //{
    //    bool atLeastOneGenerated = false;
    //    bool classMapperUsed = false;
    //    var ns = Namespace(null);
    //    var sb = new StringBuilder();
    //    var generatedBaseTypes = new HashSet<string>();
    //    if (types == null || !types.Any())
    //        return null;
    //    using (new ClassScope(sb, "MappingExtensions", ns))
    //    {
    //        var dtoTypeDict = types.ToDictionary(t => t.ToDisplayString(), t => t);

    //        // 1. Hilfsmethoden pro DTO-Basistyp erzeugen
    //        foreach (var baseType in types.Select(type => type.BaseType))
    //        {
    //            if (baseType == null) continue;
    //            var baseTypeKey = baseType.ToDisplayString();
    //            if (generatedBaseTypes.Contains(baseTypeKey)) continue;

    //            if (dtoTypeDict.TryGetValue(baseTypeKey, out var baseTypeSymbol))
    //            {
    //                var baseAutoGenAttr = baseTypeSymbol.ClassCfg(_symbols);
    //                if (baseAutoGenAttr != null)
    //                {
    //                    generatedBaseTypes.Add(baseTypeKey);

    //                    var baseDtoName = DtoGenerationSymbols.GetDtoClassName(baseType, baseAutoGenAttr, false);
    //                    var netBaseName = baseType.ToDisplayString();

    //                    // Hilfsmethode: Entity -> DTO
    //                    var baseProps = DtoGenerationSymbols.GetDtoProperties(baseType, _symbols.Ignore).ToList();
    //                    sb.AppendLine($"\t\tpublic static void AssignBaseProperties(this {baseDtoName} dto, {netBaseName} src)");
    //                    sb.AppendLine("\t\t{");
    //                    foreach (var prop in baseProps)
    //                    {
    //                        var propAttr = prop.PropertyCfg(_symbols);
    //                        var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, false);
    //                        var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
    //                        sb.AppendLine($"\t\t\tdto.{propName} = src.{prop.Name};");
    //                    }
    //                    sb.AppendLine("\t\t}");

    //                    // Hilfsmethode: DTO -> Entity
    //                    sb.AppendLine($"\t\tpublic static void AssignBaseProperties(this {netBaseName} entity, {baseDtoName} dto)");
    //                    sb.AppendLine("\t\t{");
    //                    foreach (var prop in baseProps)
    //                    {
    //                        var propAttr = prop.PropertyCfg(_symbols);
    //                        var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, false);
    //                        var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
    //                        sb.AppendLine($"\t\t\tentity.{prop.Name} = dto.{propName};");
    //                    }
    //                    sb.AppendLine("\t\t}");
    //                }
    //            }
    //        }

    //        // 2. Eigentliche Mapping-Methoden
    //        foreach (var type in types)
    //        {
    //            var autoGenAttr = type.ClassCfg(_symbols);
    //            if (!autoGenAttr.GenerateMapping)
    //                continue;

    //            atLeastOneGenerated = true;
    //            var toDtoMethod = DtoGenerationSymbols.GetToDtoMethodName(type, autoGenAttr);
    //            var toNetMethod = DtoGenerationSymbols.GetToSourceMethodName(type, autoGenAttr);
    //            var isEnum = type.TypeKind == TypeKind.Enum;
    //            var netTypeName = type.ToDisplayString();
    //            var dtoTypeName = DtoGenerationSymbols.GetDtoClassName(type, autoGenAttr, false);
    //            var comTypeNs = !string.IsNullOrWhiteSpace(autoGenAttr.Namespace) ? $"{autoGenAttr.Namespace}." : string.Empty;
    //            var genericParams = DtoGenerationSymbols.GetGenericTypeParameters(type);
    //            var genericConstraints = type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, dtoTypeDict);

    //            if (isEnum)
    //            {
    //                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName}? {toDtoMethod}(this {netTypeName}? src) => src.HasValue ? ({comTypeNs}{dtoTypeName})(int)src.Value : null;");
    //                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName}? {toNetMethod}(this {comTypeNs}{dtoTypeName}? src) => src.HasValue ? ({netTypeName})(int)src.Value : null;");
    //                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName} {toDtoMethod}(this {netTypeName} src) => ({comTypeNs}{dtoTypeName})(int)src;");
    //                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethod}(this {comTypeNs}{dtoTypeName} src) => ({netTypeName})(int)src;");
    //                continue;
    //            }

    //            var comProps = DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore).ToList();

    //            // Forward Mapping: Source → DTO
    //            sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName}{genericParams} {toDtoMethod}{genericParams}(this {netTypeName} src) {genericConstraints}");
    //            sb.AppendLine("\t\t{");
    //            sb.AppendLine("\t\t\tif(src == null) return null;");
    //            sb.AppendLine($"\t\t\tvar result = new {comTypeNs}{dtoTypeName}{genericParams}();");

    //            // --- Basismapping aufrufen, falls Basisklasse mit DTO vorhanden
    //            var baseType = type.BaseType;
    //            if (baseType != null && dtoTypeDict.TryGetValue(baseType.ToDisplayString(), out var baseTypeSymbol))
    //            {
    //                var baseAutoGenAttr = baseTypeSymbol.ClassCfg(_symbols);
    //                if (baseAutoGenAttr != null)
    //                {
    //                    var baseDtoName = DtoGenerationSymbols.GetDtoClassName(baseType, baseAutoGenAttr, false);
    //                    sb.AppendLine($"\t\t\t(( {baseDtoName} )result).AssignBaseProperties(src);");
    //                }
    //            }

    //            foreach (var prop in comProps.Where(prop => !_symbols.PropertyInBaseType(prop, type.BaseType, dtoTypeDict)))
    //            {
    //                var mappAssignment = GeneratePropertyMappingAssignment(prop, dtoTypeDict, false);
    //                classMapperUsed = classMapperUsed || mappAssignment.ClassMapperUsed;
    //                sb.AppendLine(mappAssignment.Result);
    //            }

    //            sb.AppendLine("\t\t\treturn result;");
    //            sb.AppendLine("\t\t}");

    //            // Reverse Mapping: DTO → Source
    //            sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethod}{genericParams}(this {comTypeNs}{dtoTypeName}{genericParams} src) {genericConstraints}");
    //            sb.AppendLine("\t\t{");
    //            sb.AppendLine("\t\t\tif(src == null) return null;");
    //            sb.AppendLine($"\t\t\tvar result = new {netTypeName}();");

    //            // --- Basismapping zurück
    //            if (baseType != null && dtoTypeDict.TryGetValue(baseType.ToDisplayString(), out var baseTypeSymbol2))
    //            {
    //                var baseAutoGenAttr2 = baseTypeSymbol2.ClassCfg(_symbols);
    //                if (baseAutoGenAttr2 != null)
    //                {
    //                    var baseDtoName = DtoGenerationSymbols.GetDtoClassName(baseType, baseAutoGenAttr2, false);
    //                    sb.AppendLine($"\t\t\tresult.AssignBaseProperties(( {baseDtoName} )src);");
    //                }
    //            }
    //            // --- Eigene Properties zurück
    //            foreach (var prop in comProps.Where(prop => !_symbols.PropertyInBaseType(prop, type.BaseType, dtoTypeDict)))
    //            {
    //                var assignment = GeneratePropertyMappingAssignment(prop, dtoTypeDict, true);
    //                classMapperUsed = classMapperUsed || assignment.ClassMapperUsed;
    //                sb.AppendLine(assignment.Result);
    //            }
    //            sb.AppendLine("\t\t\treturn result;");
    //            sb.AppendLine("\t\t}");
    //        }
    //        sb.AppendLine("\t}");
    //    }

    //    if(!atLeastOneGenerated)
    //        return null;
    //    if (classMapperUsed)
    //        sb.Insert(0, "using Nextended.Core.Extensions;");
    //    return new GeneratedFile("MappingExtensions.g.cs", ns, sb.ToString(), _config?.MappingOutputPath ?? _config?.OutputPath);

    //}




    public string GenerateGuids()
    {
        if (!_comIds.Any()) return string.Empty;

        var sb = new StringBuilder();
        sb.AppendLine("\t#region ComGuids");
        sb.AppendLine($"\t{_config.ComIdClassModifier.ToCSharpKeyword()} static partial class {_config.ComIdClassName}");
        sb.AppendLine("\t{");
        foreach (var kv in _comIds)
            sb.AppendLine($"\t\tpublic const string {string.Format(_config.ComIdClassPropertyFormat, kv.Key)} = \"{kv.Value}\";");
        sb.AppendLine("\t}");
        sb.AppendLine("\t#endregion ComGuids");
        return sb.ToString();
    }

    public string GenerateEnum(INamedTypeSymbol enumType, AutoGenerateDtoAttribute classAttr, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        var comName = DtoGenerationSymbols.GetDtoClassName(enumType, classAttr, false);
        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{enumType.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf("\t[ComVisible(true)]", classAttr.IsComCompatible);
        if (classAttr.IsComCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLine($"\t{classAttr.ClassModifier.ToCSharpKeyword()} enum {comName}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>().Where(f => f.IsConst))
        {
            if (_symbols.Ignore != null && member.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, _symbols.Ignore)))
                continue;
            if (_config.CreateComments) sb.AppendLine($"\t\t/// <summary>{member.Name}</summary>");
            sb.AppendLineIf($"\t\t[DispId({++dispId})]", classAttr.IsComCompatible);
            sb.AppendLine($"\t\t{member.Name} = {member.ConstantValue},");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public string GenerateInterface(INamedTypeSymbol type,
        AutoGenerateDtoAttribute classAttr,
        Dictionary<string, INamedTypeSymbol> dtoTypeDict,
        bool addGeneric)
    {
        var comInterfaceName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, true);
        var comName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, false);
        var genericParams = addGeneric ? DtoGenerationSymbols.GetGenericTypeParameters(type) : "";
        var comCompatible = classAttr.IsComCompatible;

        var genericConstraints =
            type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, dtoTypeDict);
        classAttr.Interfaces ??= _config.Interfaces;

        var baseTypeStr = _symbols.GetBaseTypeString(type, classAttr, dtoTypeDict, true);

        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comInterfaceName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");

        sb.AppendAttributesIf(type, classAttr?.KeepAttributesOnGeneratedInterface ?? false);
        sb.AppendLineIf("\t[ComVisible(true)]", comCompatible);
        if (comCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLineIf("\t[TypeLibType(TypeLibTypeFlags.FDual | TypeLibTypeFlags.FDispatchable)]", comCompatible);
        sb.AppendLineIf(classAttr.PreInterfaceString, !string.IsNullOrEmpty(classAttr.PreInterfaceString));
        sb.AppendLine($"\t{classAttr.InterfaceModifier.ToCSharpKeyword()} {(_config.GeneratePartial ? "partial " : "")}interface {comInterfaceName}{genericParams} {baseTypeStr} {genericConstraints}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.PropertyCfg(_symbols);
            var getterSetter = DtoGenerationSymbols.ResolveInterfaceAccess(prop, classAttr, _symbols).ToCSharpKeyword();

            var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, true);
            var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);

            sb.AppendAttributesIf(prop, propAttr?.KeepAttributesOnGeneratedInterface ?? classAttr?.KeepPropertyAttributesOnGeneratedInterface ?? false, 2);
            sb.AppendLineIf(propAttr?.PreInterfaceString, !string.IsNullOrEmpty(propAttr?.PreInterfaceString));

            sb.AppendLineIf($"\t\t[DispId({++dispId})]", comCompatible);
            var ns = _symbols.GetNamespaceForProperty(prop, dtoTypeDict);
            sb.AppendLine($"\t\t{ns}{propTypeString} {propName} {{ {getterSetter} }}");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public string GenerateClass(INamedTypeSymbol type, AutoGenerateDtoAttribute classAttr,
        Dictionary<string, INamedTypeSymbol> dtoTypeDict,
        bool addGeneric)
    {
        var comName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, false);
        var comInterfaceName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, true);
        var genericParams = addGeneric ? DtoGenerationSymbols.GetGenericTypeParameters(type) : "";
        var comCompatible = classAttr.IsComCompatible;

        var genericConstraints = type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, dtoTypeDict);
        
        var baseTypeStr = _symbols.GetBaseTypeString(type, [], dtoTypeDict, false)?.Replace(":", "");
        if (string.IsNullOrWhiteSpace(baseTypeStr))
            baseTypeStr = classAttr.BaseType ??= _config.BaseType;
        baseTypeStr = !string.IsNullOrEmpty(baseTypeStr) ? $"{baseTypeStr}, " : "";

        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf($"\t[ComVisible(true)]", comCompatible);
        if (comCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendAttributesIf(type, classAttr?.KeepAttributesOnGeneratedClass ?? false);
        sb.AppendLineIf(classAttr.PreClassString, !string.IsNullOrEmpty(classAttr.PreClassString));
        var modelType = _config.ModelType; // TODO: class attr cfg
        var abstractPrefix = (_config.MakeDtoAbstractWhenSourceIsAbstract && type.IsAbstract) ? "abstract " : "";

        sb.AppendLine($"\t{classAttr.ClassModifier.ToCSharpKeyword()} {abstractPrefix}{(_config.GeneratePartial ? "partial " : "")}{modelType.ToCSharpKeyword()} {comName}{genericParams} : {baseTypeStr}{comInterfaceName}{genericParams} {genericConstraints}");
        sb.AppendLine("\t{");
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.PropertyCfg(_symbols);
            var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, false);
            var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
            var ns = _symbols.GetNamespaceForProperty(prop, dtoTypeDict);

            sb.AppendLine($"\t\tpublic {ns}{propTypeString} {propName} {{ get; set; }}");
        }
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propType = prop.Type;
            
            if (DtoGenerationSymbols.IsDtoType(propType, dtoTypeDict) && !DtoGenerationSymbols.IsDtoEnumType(propType, dtoTypeDict))
            {
                var propAttr = prop.PropertyCfg(_symbols);

                var targetClass = dtoTypeDict.ContainsKey(propType.ToDisplayString()) ? dtoTypeDict[propType.ToDisplayString()] : dtoTypeDict[DtoGenerationSymbols.NormalizeForLookup(propType).ToDisplayString()];
                var targetAttr = targetClass.ClassCfg(_symbols);
                var interfaceAccess = DtoGenerationSymbols.ResolveInterfaceAccess(prop, classAttr, _symbols);

                var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, false);
                var comInterfaceTypeName = DtoGenerationSymbols.GetDtoClassName(targetClass, targetAttr, true);
                var thisInterface = comInterfaceName;
                var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
                var ns = _symbols.GetNamespaceForProperty(prop, dtoTypeDict);

                sb.AppendAttributesIf(prop, propAttr?.KeepAttributesOnGeneratedClass ?? classAttr?.KeepPropertyAttributesOnGeneratedClass ?? false, 2);
                sb.AppendLineIf(propAttr?.PreClassString, !string.IsNullOrEmpty(propAttr?.PreClassString));
                // Explicit interface implementation for properties of DTOs
                if(interfaceAccess is InterfaceProperty.GetAndSet or InterfaceProperty.Unset)
                    sb.AppendLine($"\t\t{ns}{comInterfaceTypeName} {thisInterface}.{propName} {{ get => {propName}; set => {propName} = ({ns}{propTypeString})value; }}");
                else if (interfaceAccess == InterfaceProperty.Get)
                    sb.AppendLine($"\t\t{ns}{comInterfaceTypeName} {thisInterface}.{propName} {{ get => {propName}; }}");
                else if(interfaceAccess == InterfaceProperty.Set)
                    sb.AppendLine($"\t\t{ns}{comInterfaceTypeName} {thisInterface}.{propName} {{ set => {propName} = ({ns}{propTypeString})value; }}");
            }
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }


    public GeneratedFile GenerateComIdFile(IEnumerable<INamedTypeSymbol> allTypes)
    {
        if (!_comIds.Any())
            return null;

        var ns = Namespace(null);
        var usings = new[] { "System" };
        var sb = new StringBuilder();
        sb.AppendFileHeader();
        sb.AppendUsings(usings);
        sb.OpenNamespace(ns);
        sb.AppendLine(GenerateGuids());
        sb.CloseNamespace();

        var fileName = $"{_config.ComIdClassName}.g.cs";
        return new GeneratedFile(fileName, ns, sb.ToString(), _config);
    }

    public (string Id, string ClassName) GetGuid(string className)
    {
        if (!_comIds.TryGetValue(className, out var guid))
        {
            guid = Guid.NewGuid().ToString();
            _comIds[className] = guid;
        }
        return (guid, $"{Namespace(null)}.{_config.ComIdClassName}.{string.Format(_config.ComIdClassPropertyFormat, className)}");
    }

    internal string Namespace(INamedTypeSymbol? type)
    {
        return _symbols.Namespace(type);
    }
}
