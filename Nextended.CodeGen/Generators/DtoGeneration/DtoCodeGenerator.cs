using Microsoft.CodeAnalysis;
using Nextended.CodeGen.Attributes;
using Nextended.CodeGen.Config;
using Nextended.CodeGen.Helper;
using Nextended.Core.Extensions;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Nextended.CodeGen.Generators.DtoGeneration;

public class DtoCodeGenerator
{
    private readonly DtoGenerationConfig _config;
    private readonly DtoGenerationSymbols _symbols;
    private readonly Dictionary<string, string> _comIds = new();

    public DtoCodeGenerator(DtoGenerationConfig config, DtoGenerationSymbols symbols)
    {
        _config = config;
        _symbols = symbols;
    }

    public bool HasGuids => _comIds.Any();

    /// <summary>
    /// Hauptmethode für die Dateierzeugung zu einem Typ (für OneFilePerClass = true).
    /// </summary>
    public DtoGeneratedFile GenerateAllForType(INamedTypeSymbol type, List<INamedTypeSymbol> allTypes)
    {
        var autoGenAttr = type.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);
        var ns = autoGenAttr?.Namespace ?? _config.Namespace;
        var comTypeDict = allTypes.ToDictionary(t => t.ToDisplayString(), t => t);

        var fileName = $"{GetComClassName(type, autoGenAttr, false)}.g.cs";

        var usings = new HashSet<string>(_config.Usings ?? Enumerable.Empty<string>())
        {
            "System",
            "System.Runtime.InteropServices"
        };
        usings.Add(type.ContainingNamespace.ToDisplayString());
        usings.UnionWith(GetReferencedNamespaces(type, comTypeDict));

        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated />");
        foreach (var u in usings.Where(x => !string.IsNullOrWhiteSpace(x)))
            sb.AppendLine($"using {u};");

        sb.AppendLine($"namespace {ns} {{");

        if (_config.CreateRegions)
            sb.AppendLine($"\t#region COM For {type.Name}");

        if (type.TypeKind == TypeKind.Enum)
        {
            sb.AppendLine(GenerateEnum(type, autoGenAttr, comTypeDict));
        }
        else
        {
            sb.AppendLine(GenerateInterface(type, autoGenAttr, comTypeDict));
            sb.AppendLine(GenerateClass(type, autoGenAttr, comTypeDict));
        }

        if (_config.CreateRegions)
            sb.AppendLine($"\t#endregion COM For {type.Name}");

        //if (_comIds.Any())
        //    sb.AppendLine(GenerateGuids());

        sb.AppendLine("}");

        return new DtoGeneratedFile(fileName, ns, sb.ToString(), usings);
    }

    /// <summary>
    /// Methode für OneFilePerClass == false. Generiert eine Datei für alle Typen eines Namespaces.
    /// </summary>
    public DtoGeneratedFile GenerateNamespaceFile(string ns, IEnumerable<INamedTypeSymbol> types, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        var usings = new HashSet<string>(_config.Usings ?? Enumerable.Empty<string>())
        {
            "System",
            "System.Runtime.InteropServices"
        };
        foreach (var t in types)
        {
            usings.Add(t.ContainingNamespace.ToDisplayString());
            usings.UnionWith(GetReferencedNamespaces(t, comTypeDict));
        }

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        foreach (var u in usings.Where(x => !string.IsNullOrWhiteSpace(x)))
            sb.AppendLine($"using {u};");
        sb.AppendLine($"namespace {ns} {{");

        foreach (var type in types)
        {
            var autoGenAttr = type.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);

            if (_config.CreateRegions)
                sb.AppendLine($"\t#region COM For {type.Name}");

            if (type.TypeKind == TypeKind.Enum)
            {
                sb.AppendLine(GenerateEnum(type, autoGenAttr, comTypeDict));
            }
            else
            {
                sb.AppendLine(GenerateInterface(type, autoGenAttr, comTypeDict));
                sb.AppendLine(GenerateClass(type, autoGenAttr, comTypeDict));
            }

            if (_config.CreateRegions)
                sb.AppendLine($"\t#endregion COM For {type.Name}");
        }

        //if (_comIds.Any())
        //    sb.AppendLine(GenerateGuids());

        sb.AppendLine("}");

        var fileName = $"{ns}.AllDtos.g.cs";
        return new DtoGeneratedFile(fileName, ns, sb.ToString(), usings);
    }

    public DtoGeneratedFile? GenerateMappingExtensions(List<INamedTypeSymbol> types)
    {
        //if (!_config.GenerateMappingExtensions)
        //    return null;

        var ns = _config.Namespace;
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine($"namespace {ns} {{");
        sb.AppendLine("\tpublic static partial class MappingExtensions");
        sb.AppendLine("\t{");

        var comTypeDict = types.ToDictionary(t => t.ToDisplayString(), t => t);

        foreach (var type in types)
        {
            var autoGenAttr = type.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);

            var toComMethodName = GetToComMethodName(type, autoGenAttr);
            var isEnum = type.TypeKind == TypeKind.Enum;
            var netTypeName = type.ToDisplayString();
            var comTypeName = GetComClassName(type, autoGenAttr, false);

            if (isEnum)
            {
                sb.AppendLine($"\t\tpublic static {comTypeName}? {toComMethodName}(this {netTypeName}? src) => src.HasValue ? ({comTypeName})(int)src.Value : null;");
                sb.AppendLine($"\t\tpublic static {netTypeName}? ToNet(this {comTypeName}? src) => src.HasValue ? ({netTypeName})(int)src.Value : null;");
                sb.AppendLine($"\t\tpublic static {comTypeName} {toComMethodName}(this {netTypeName} src) => ({comTypeName})(int)src;");
                sb.AppendLine($"\t\tpublic static {netTypeName} ToNet(this {comTypeName} src) => ({netTypeName})(int)src;");
                continue;
            }

            var comProps = GetComProperties(type, _symbols.Ignore).ToList();

            sb.AppendLine($"\t\tpublic static {comTypeName} {toComMethodName}(this {netTypeName} src)");
            sb.AppendLine("\t\t{");
            sb.AppendLine("\t\t\tif(src == null) return null;");
            sb.AppendLine($"\t\t\tvar result = new {comTypeName}();");
            foreach (var prop in comProps)
            {
                var propAttr = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(_symbols.PropertySetting);
                var netPropName = prop.Name;
                var comPropName = GetComPropertyName(prop, propAttr);
                var netPropType = prop.Type;

                if (IsComEnumType(netPropType, comTypeDict))
                {
                    var enumType = netPropType.UnwrapNullableTypeSymbol();
                    var targetClass = comTypeDict[enumType.ToDisplayString()];
                    var targetAttr = targetClass.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);
                    var enumToComMethod = GetToComMethodName(targetClass, targetAttr);
                    sb.AppendLine(prop.IsNullable()
                        ? $"\t\t\tresult.{comPropName} = src.{netPropName}?.{enumToComMethod}();"
                        : $"\t\t\tresult.{comPropName} = src.{netPropName}.{enumToComMethod}();");
                }
                else if (IsComType(netPropType, comTypeDict))
                {
                    var classType = netPropType.UnwrapNullableTypeSymbol();
                    var targetClass = comTypeDict[classType.ToDisplayString()];
                    var targetAttr = targetClass.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);
                    var propToComMethod = GetToComMethodName(targetClass, targetAttr);
                    sb.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName}?.{propToComMethod}();");
                }
                else
                {
                    sb.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName};");
                }
            }

            sb.AppendLine("\t\t\treturn result;");
            sb.AppendLine("\t\t}");

            sb.AppendLine($"\t\tpublic static {netTypeName} ToNet(this {comTypeName} src)");
            sb.AppendLine("\t\t{");
            sb.AppendLine("\t\t\tif(src == null) return null;");
            sb.AppendLine($"\t\t\tvar result = new {netTypeName}();");
            foreach (var prop in comProps)
            {
                var propAttr = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(_symbols.PropertySetting);
                var netPropName = prop.Name;
                var comPropName = GetComPropertyName(prop, propAttr);
                var netPropType = prop.Type;

                if (IsComEnumType(netPropType, comTypeDict))
                    sb.AppendLine(prop.IsNullable()
                        ? $"\t\t\tresult.{netPropName} = src.{comPropName}?.ToNet();"
                        : $"\t\t\tresult.{netPropName} = src.{comPropName}.ToNet();");
                else if (IsComType(netPropType, comTypeDict))
                    sb.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName}?.ToNet();");
                else
                    sb.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName};");
            }
            sb.AppendLine("\t\t\treturn result;");
            sb.AppendLine("\t\t}");
        }

        sb.AppendLine("\t}");
        sb.AppendLine("}");

        return new DtoGeneratedFile("MappingExtensions.g.cs", ns, sb.ToString(), new[] { "System" });
    }

    public string GenerateGuids()
    {
        if (!_comIds.Any()) return string.Empty;

        var sb = new StringBuilder();
        sb.AppendLine("\t#region ComGuids");
        sb.AppendLine($"\t{_config.ComIdClassModifier} static partial class {_config.ComIdClassName}");
        sb.AppendLine("\t{");
        foreach (var kv in _comIds)
            sb.AppendLine($"\t\tpublic const string {string.Format(_config.ComIdClassPropertyFormat, kv.Key)} = \"{kv.Value}\";");
        sb.AppendLine("\t}");
        sb.AppendLine("\t#endregion ComGuids");
        return sb.ToString();
    }

    public string GenerateEnum(INamedTypeSymbol enumType, AutoGenerateDtoAttribute classAttr, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        var comName = GetComClassName(enumType, classAttr, false);
        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{enumType.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf("\t[ComVisible(true)]", classAttr.IsComCompatible);
        if (classAttr.IsComCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLine($"\t{_config.ClassModifier} enum {comName}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>().Where(f => f.IsConst))
        {
            if (_symbols.Ignore != null && member.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, _symbols.Ignore)))
                continue;
            if (_config.CreateComments) sb.AppendLine($"\t\t/// <summary>{member.Name}</summary>");
            sb.AppendLineIf($"\t\t[DispId({++dispId})]", classAttr.IsComCompatible);
            sb.AppendLine($"\t\t{member.Name} = {member.ConstantValue},");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public string GenerateInterface(INamedTypeSymbol type, AutoGenerateDtoAttribute classAttr, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        var comInterfaceName = GetComClassName(type, classAttr, true);
        var comName = GetComClassName(type, classAttr, false);

        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comInterfaceName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf("\t[ComVisible(true)]", classAttr.IsComCompatible);
        if (classAttr.IsComCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLineIf("\t[TypeLibType(TypeLibTypeFlags.FDual | TypeLibTypeFlags.FDispatchable)]", classAttr.IsComCompatible);
        sb.AppendLine($"\t{_config.InterfaceModifier} {(_config.GeneratePartial ? "partial " : "")}interface {comInterfaceName}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var prop in GetComProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(_symbols.PropertySetting);
            var propTypeString = GetComPropertyType(prop, comTypeDict, _symbols, true);
            var propName = GetComPropertyName(prop, propAttr);
            sb.AppendLineIf($"\t\t[DispId({++dispId})]", classAttr.IsComCompatible);
            sb.AppendLine($"\t\t{propTypeString} {propName} {{ get; set; }}");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public string GenerateClass(INamedTypeSymbol type, AutoGenerateDtoAttribute classAttr, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        var comName = GetComClassName(type, classAttr, false);
        var comInterfaceName = GetComClassName(type, classAttr, true);

        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf($"\t[ComVisible(true)]", classAttr.IsComCompatible);
        if (classAttr.IsComCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLine($"\t{_config.ClassModifier} {(_config.GeneratePartial ? "partial " : "")}class {comName} : {comInterfaceName}");
        sb.AppendLine("\t{");
        foreach (var prop in GetComProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(_symbols.PropertySetting);
            var propTypeString = GetComPropertyType(prop, comTypeDict, _symbols, false);
            var propName = GetComPropertyName(prop, propAttr);
            sb.AppendLine($"\t\tpublic {propTypeString} {propName} {{ get; set; }}");
        }
        foreach (var prop in GetComProperties(type, _symbols.Ignore))
        {
            var propType = prop.Type;
            if (IsComType(propType, comTypeDict) && !IsComEnumType(propType, comTypeDict))
            {
                var propAttr = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(_symbols.PropertySetting);
                var targetClass = comTypeDict[propType.ToDisplayString()];
                var targetAttr = targetClass.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);
                var propTypeString = GetComPropertyType(prop, comTypeDict, _symbols, false);
                var comInterfaceTypeName = GetComClassName(targetClass, targetAttr, true);
                var thisInterface = comInterfaceName;
                var propName = GetComPropertyName(prop, propAttr);
                sb.AppendLine($"\t\t{comInterfaceTypeName} {thisInterface}.{propName} {{ get => {propName}; set => {propName} = ({propTypeString})value; }}");
            }
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public DtoGeneratedFile GenerateComIdFile(IEnumerable<INamedTypeSymbol> allTypes)
    {
        if (!_comIds.Any())
            return null;

        var ns = _config.Namespace;
        var usings = new[] { "System" };

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        foreach (var u in usings)
            sb.AppendLine($"using {u};");
        sb.AppendLine($"namespace {ns} {{");
        sb.AppendLine(GenerateGuids());
        sb.AppendLine("}");

        var fileName = $"{_config.ComIdClassName}.g.cs";
        return new DtoGeneratedFile(fileName, ns, sb.ToString(), usings);
    }

    // ----- Helpers -----

    public static string GetComClassName(INamedTypeSymbol type, AutoGenerateDtoAttribute? attr, bool asInterface)
    {
        var main = !string.IsNullOrEmpty(attr?.GeneratedClassName) ? attr.GeneratedClassName : type.Name;
        int idx = main.IndexOf('`');
        if (idx >= 0) main = main.Substring(0, idx);
        var prefix = attr?.Prefix ?? string.Empty;
        var suffix = attr?.Suffix ?? string.Empty;
        return $"{(asInterface ? "I" : "")}{prefix}{main}{suffix}";
    }

    public static string GetComPropertyName(IPropertySymbol prop, GenerationPropertySettingAttribute? info)
        => !string.IsNullOrEmpty(info?.PropertyName) ? info.PropertyName : prop.Name;

    public static string GetToComMethodName(INamedTypeSymbol type, AutoGenerateDtoAttribute? attr)
    {
        if (attr != null && !string.IsNullOrWhiteSpace(attr.ToDtoMethodName))
            return attr.ToDtoMethodName;
        return $"To{attr?.Prefix}{attr?.Suffix}";
    }

    public static IEnumerable<IPropertySymbol> GetComProperties(INamedTypeSymbol type, INamedTypeSymbol? ignoreAttr)
        => type.GetMembers().OfType<IPropertySymbol>().Where(p =>
            p.DeclaredAccessibility == Accessibility.Public &&
            !p.IsStatic &&
            (ignoreAttr == null || !p.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, ignoreAttr)))
        );

    public static string GetComPropertyType(
        IPropertySymbol prop,
        Dictionary<string, INamedTypeSymbol> comTypes,
        DtoGenerationSymbols symbols,
        bool asInterface)
    {
        var propType = prop.Type;
        bool isNullable = false;
        ITypeSymbol underlyingType = propType;
        if (propType is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nts)
        {
            isNullable = true;
            underlyingType = nts.TypeArguments[0];
        }
        string typeString;
        if (IsComEnumType(underlyingType, comTypes))
        {
            var targetClass = comTypes[underlyingType.ToDisplayString()];
            var targetAttr = targetClass.GetAttributeInstance<AutoGenerateDtoAttribute>(symbols.AutoGenerateDto);
            typeString = GetComClassName(targetClass, targetAttr, false);
        }
        else if (IsComType(underlyingType, comTypes))
        {
            var targetClass = comTypes[underlyingType.ToDisplayString()];
            var targetAttr = targetClass.GetAttributeInstance<AutoGenerateDtoAttribute>(symbols.AutoGenerateDto);
            typeString = GetComClassName(targetClass, targetAttr, asInterface);
        }
        else
        {
            typeString = underlyingType.ToDisplayString();
        }
        if (isNullable && !typeString.EndsWith("?"))
            typeString += "?";
        return typeString;
    }

    public static bool IsComType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
        => comTypes.ContainsKey(type.ToDisplayString());

    public static bool IsComEnumType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
    {
        if (type is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nts)
            type = nts.TypeArguments[0];
        return comTypes.TryGetValue(type.ToDisplayString(), out var t) && t.TypeKind == TypeKind.Enum;
    }

    public (string Id, string ClassName) GetGuid(string className)
    {
        if (!_comIds.TryGetValue(className, out var guid))
        {
            guid = Guid.NewGuid().ToString();
            _comIds[className] = guid;
        }
        return (guid, $"{_config.ComIdClassName}.{string.Format(_config.ComIdClassPropertyFormat, className)}");
    }

    /// <summary>
    /// Liefert alle Namespaces, auf die Properties des Typs verweisen (für Usings).
    /// </summary>
    public static IEnumerable<string> GetReferencedNamespaces(
        INamedTypeSymbol type,
        Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        return GetComProperties(type, null)
            .Select(p => p.Type)
            .Where(t => comTypeDict.ContainsKey(t.ToDisplayString()))
            .Select(t => comTypeDict[t.ToDisplayString()].ContainingNamespace.ToDisplayString())
            .Where(ns => !string.IsNullOrWhiteSpace(ns));
    }
}
