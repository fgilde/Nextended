using Microsoft.CodeAnalysis;
using Nextended.CodeGen.Attributes;
using Nextended.CodeGen.Config;
using Nextended.CodeGen.Helper;
using Nextended.Core.Extensions;
using System.Text;
using Nextended.CodeGen.Enums;

namespace Nextended.CodeGen.Generators.DtoGeneration;

public class DtoCodeGenerator
{
    private readonly DtoGenerationConfig _config;
    private readonly DtoGenerationSymbols _symbols;
    private readonly Dictionary<string, string> _comIds = new();

    public DtoCodeGenerator(DtoGenerationConfig config, DtoGenerationSymbols symbols)
    {
        _config = config;
        _symbols = symbols;
    }

    public bool HasGuids => _comIds.Any();

    /// <summary>
    /// Hauptmethode für die Dateierzeugung zu einem Typ (für OneFilePerClass = true).
    /// </summary>
    public DtoGeneratedFile GenerateAllForType(INamedTypeSymbol type, List<INamedTypeSymbol> allTypes)
    {
        var autoGenAttr = type.ClassCfg(_symbols);
        var ns = Namespace;
        var comTypeDict = allTypes.ToDictionary(t => t.ToDisplayString(), t => t);

        var fileName = $"{DtoGenerationSymbols.GetDtoClassName(type, autoGenAttr, false)}.g.cs";
        var usings = DtoGenerationSymbols.GetUsings(type, comTypeDict, autoGenAttr, _config);

        var sb = new StringBuilder();

        sb.AppendFileHeader(fileName)
            .AppendUsings(usings);
        using (new NamespaceScope(sb, ns))
        {
            GenerateType(type, sb, autoGenAttr, comTypeDict);
        }

        return new DtoGeneratedFile(fileName, ns, sb.ToString(), usings);
    }

    /// <summary>
    /// Methode für OneFilePerClass == false. Generiert eine Datei für alle Typen eines Namespaces.
    /// </summary>
    public DtoGeneratedFile GenerateNamespaceFile(string ns, IEnumerable<INamedTypeSymbol> types, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        var usings = DtoGenerationSymbols.GetUsings(types, comTypeDict, null, _config);

        var sb = new StringBuilder();
        sb.AppendFileHeader()
            .AppendUsings(usings);

        using (new NamespaceScope(sb, ns))
        {
            foreach (var type in types)
            {
                var autoGenAttr = type.ClassCfg(_symbols);
                GenerateType(type, sb, autoGenAttr, comTypeDict);
            }
        }

        var fileName = $"{ns}.AllDtos.g.cs";
        return new DtoGeneratedFile(fileName, ns, sb.ToString(), usings);
    }

    private void GenerateType(INamedTypeSymbol type, StringBuilder sb, AutoGenerateDtoAttribute autoGenAttr, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        var regionName = DtoGenerationSymbols.RegionNameFor(type, autoGenAttr);
        sb.OpenRegion(regionName, _config.CreateRegions);

        if (type.TypeKind == TypeKind.Enum)
        {
            sb.AppendLine(GenerateEnum(type, autoGenAttr, comTypeDict));
        }
        else
        {
            sb.AppendLine(GenerateInterface(type, autoGenAttr, comTypeDict, true));
            sb.AppendLine(GenerateClass(type, autoGenAttr, comTypeDict, true));
        }
        sb.CloseRegion(regionName, _config.CreateRegions);
    }

    private string GeneratePropertyMappingAssignment(IPropertySymbol prop, Dictionary<string, INamedTypeSymbol> comTypeDict, bool reverse)
    {
        var propAttr = prop.PropertyCfg(_symbols);

        var netPropName = prop.Name;
        var comPropName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
        var netPropType = prop.Type;

        var targetName = !reverse ? comPropName : netPropName;
        var sourceName = !reverse ? netPropName : comPropName;

        // Helper-Funktion: Liefert für reverse/source richtig den Target-Type für MapTo<>
        string GetTargetType(ITypeSymbol typeSymbol, bool reverseDir)
        {
            if (typeSymbol is INamedTypeSymbol nts)
            {
                var autoGenAttr = nts.ClassCfg(_symbols);
                return !reverseDir
                    ? $"{DtoGenerationSymbols.GetDtoClassName(nts, autoGenAttr, false)}{DtoGenerationSymbols.GetGenericTypeParameters(nts)}"
                    : nts.ToDisplayString(); // enthält generics schon
            }
            return typeSymbol.ToDisplayString();
        }

        if (DtoGenerationSymbols.IsDtoEnumType(netPropType, comTypeDict))
        {
            var enumType = netPropType.UnwrapNullableTypeSymbol();
            var targetClass = comTypeDict[enumType.ToDisplayString()];
            var targetAttr = targetClass.ClassCfg(_symbols);

            if (!targetAttr.GenerateMapping || (propAttr?.MapWithClassMapper ?? false))
            {
                var targetTypeString = GetTargetType(targetClass, reverse);
                return prop.IsNullable()
                    ? $"\t\t\tresult.{targetName} = src.{sourceName}?.MapTo<{targetTypeString}>();"
                    : $"\t\t\tresult.{targetName} = src.{sourceName}.MapTo<{targetTypeString}>();";
            }

            var enumToComMethod = !reverse
                ? DtoGenerationSymbols.GetToDtoMethodName(targetClass, targetAttr)
                : DtoGenerationSymbols.GetToSourceMethodName(targetClass, targetAttr);

            return prop.IsNullable()
                ? $"\t\t\tresult.{targetName} = src.{sourceName}?.{enumToComMethod}();"
                : $"\t\t\tresult.{targetName} = src.{sourceName}.{enumToComMethod}();";
        }

        if (DtoGenerationSymbols.IsDtoType(netPropType, comTypeDict))
        {
            var classType = netPropType.UnwrapNullableTypeSymbol();
            var targetClass = comTypeDict[classType.ToDisplayString()];
            var targetAttr = targetClass.ClassCfg(_symbols);

            if (!targetAttr.GenerateMapping || (propAttr?.MapWithClassMapper ?? false))
            {
                var targetTypeString = GetTargetType(targetClass, reverse);
                return prop.IsNullable()
                    ? $"\t\t\tresult.{targetName} = src.{sourceName}?.MapTo<{targetTypeString}>();"
                    : $"\t\t\tresult.{targetName} = src.{sourceName}.MapTo<{targetTypeString}>();";
            }

            var propToComMethod = !reverse
                ? DtoGenerationSymbols.GetToDtoMethodName(targetClass, targetAttr)
                : DtoGenerationSymbols.GetToSourceMethodName(targetClass, targetAttr);

            return $"\t\t\tresult.{targetName} = src.{sourceName}?.{propToComMethod}();";
        }
        return $"\t\t\tresult.{targetName} = src.{sourceName};";
    }

    public DtoGeneratedFile? GenerateMappingExtensions(List<INamedTypeSymbol> types)
    {
        var ns = Namespace;
        var sb = new StringBuilder();

        using (new ClassScope(sb, "MappingExtensions", ns))
        {
            var comTypeDict = types.ToDictionary(t => t.ToDisplayString(), t => t);

            foreach (var type in types)
            {
                var autoGenAttr = type.ClassCfg(_symbols);
                if (!autoGenAttr.GenerateMapping)
                    continue;

                var toComMethodName = DtoGenerationSymbols.GetToDtoMethodName(type, autoGenAttr);
                var toNetMethodName = DtoGenerationSymbols.GetToSourceMethodName(type, autoGenAttr);
                var isEnum = type.TypeKind == TypeKind.Enum;
                var netTypeName = type.ToDisplayString();
                var comTypeName = DtoGenerationSymbols.GetDtoClassName(type, autoGenAttr, false);
                var comTypeNs = !string.IsNullOrWhiteSpace(autoGenAttr.Namespace) ? $"{autoGenAttr.Namespace}." : string.Empty;
                var genericParams = DtoGenerationSymbols.GetGenericTypeParameters(type);
                var genericConstraints = type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, comTypeDict);

                if (isEnum)
                {
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{comTypeName}? {toComMethodName}(this {netTypeName}? src) => src.HasValue ? ({comTypeNs}{comTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName}? {toNetMethodName}(this {comTypeNs}{comTypeName}? src) => src.HasValue ? ({netTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{comTypeName} {toComMethodName}(this {netTypeName} src) => ({comTypeNs}{comTypeName})(int)src;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethodName}(this {comTypeNs}{comTypeName} src) => ({netTypeName})(int)src;");
                    continue;
                }

                var comProps = DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore).ToList();

                // Forward Mapping: Source → DTO
                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{comTypeName}{genericParams} {toComMethodName}{genericParams}(this {netTypeName} src) {genericConstraints}");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(src == null) return null;");
                sb.AppendLine($"\t\t\tvar result = new {comTypeNs}{comTypeName}{genericParams}();");

                foreach (var prop in comProps)
                {
                    sb.AppendLine(GeneratePropertyMappingAssignment(prop, comTypeDict, false));
                }

                sb.AppendLine("\t\t\treturn result;");
                sb.AppendLine("\t\t}");

                // Reverse Mapping: DTO → Source
                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethodName}{genericParams}(this {comTypeNs}{comTypeName}{genericParams} src) {genericConstraints}");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(src == null) return null;");
                sb.AppendLine($"\t\t\tvar result = new {netTypeName}();");
                foreach (var prop in comProps)
                {
                    sb.AppendLine(GeneratePropertyMappingAssignment(prop, comTypeDict, true));
                }
                sb.AppendLine("\t\t\treturn result;");
                sb.AppendLine("\t\t}");
            }
            sb.AppendLine("\t}");
        }

        return new DtoGeneratedFile("MappingExtensions.g.cs", ns, sb.ToString(), new[] { "System" });
    }



    public string GenerateGuids()
    {
        if (!_comIds.Any()) return string.Empty;

        var sb = new StringBuilder();
        sb.AppendLine("\t#region ComGuids");
        sb.AppendLine($"\t{_config.ComIdClassModifier.ToCSharpKeyword()} static partial class {_config.ComIdClassName}");
        sb.AppendLine("\t{");
        foreach (var kv in _comIds)
            sb.AppendLine($"\t\tpublic const string {string.Format(_config.ComIdClassPropertyFormat, kv.Key)} = \"{kv.Value}\";");
        sb.AppendLine("\t}");
        sb.AppendLine("\t#endregion ComGuids");
        return sb.ToString();
    }

    public string GenerateEnum(INamedTypeSymbol enumType, AutoGenerateDtoAttribute classAttr, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        var comName = DtoGenerationSymbols.GetDtoClassName(enumType, classAttr, false);
        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{enumType.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf("\t[ComVisible(true)]", classAttr.IsComCompatible);
        if (classAttr.IsComCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLine($"\t{classAttr.ClassModifier.ToCSharpKeyword()} enum {comName}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>().Where(f => f.IsConst))
        {
            if (_symbols.Ignore != null && member.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, _symbols.Ignore)))
                continue;
            if (_config.CreateComments) sb.AppendLine($"\t\t/// <summary>{member.Name}</summary>");
            sb.AppendLineIf($"\t\t[DispId({++dispId})]", classAttr.IsComCompatible);
            sb.AppendLine($"\t\t{member.Name} = {member.ConstantValue},");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public string GenerateInterface(INamedTypeSymbol type,
        AutoGenerateDtoAttribute classAttr,
        Dictionary<string, INamedTypeSymbol> comTypeDict,
        bool addGeneric)
    {
        var comInterfaceName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, true);
        var comName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, false);
        var genericParams = addGeneric ? DtoGenerationSymbols.GetGenericTypeParameters(type) : "";
        var comCompatible = classAttr.IsComCompatible;

        var genericConstraints =
            type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, comTypeDict);
        classAttr.Interfaces ??= _config.Interfaces;
        var baseTypeStr = classAttr.Interfaces?.Any() ?? false ? $":{string.Join(", ", classAttr.Interfaces)}" : "";


        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine(
                $"\t/// <summary>{comInterfaceName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");

        sb.AppendAttributesIf(type, classAttr?.KeepAttributesOnGeneratedInterface ?? false);
        sb.AppendLineIf("\t[ComVisible(true)]", comCompatible);
        if (comCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLineIf("\t[TypeLibType(TypeLibTypeFlags.FDual | TypeLibTypeFlags.FDispatchable)]", comCompatible);
        sb.AppendLineIf(classAttr.PreInterfaceString, !string.IsNullOrEmpty(classAttr.PreInterfaceString));
        sb.AppendLine($"\t{classAttr.InterfaceModifier.ToCSharpKeyword()} {(_config.GeneratePartial ? "partial " : "")}interface {comInterfaceName}{genericParams} {baseTypeStr} {genericConstraints}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.PropertyCfg(_symbols);
            var getterSetter = (propAttr?.InterfaceAccess ?? classAttr.DefaultPropertyInterfaceAccess).ToCSharpKeyword();
            var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, comTypeDict, _symbols, true);
            var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);

            sb.AppendAttributesIf(prop, propAttr?.KeepAttributesOnGeneratedInterface ?? classAttr?.KeepPropertyAttributesOnGeneratedInterface ?? false, 2);
            sb.AppendLineIf(propAttr?.PreInterfaceString, !string.IsNullOrEmpty(propAttr?.PreInterfaceString));

            sb.AppendLineIf($"\t\t[DispId({++dispId})]", comCompatible);
            var ns = GetNamespaceForProperty(prop, comTypeDict);
            sb.AppendLine($"\t\t{ns}{propTypeString} {propName} {{ {getterSetter} }}");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    private string GetNamespaceForProperty(IPropertySymbol property, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        var result = GetClassCfgForType(property.Type, comTypeDict)?.Namespace;
        return string.IsNullOrWhiteSpace(result) ? string.Empty : $"{result}.";
    }

    private AutoGenerateDtoAttribute? GetClassCfgForType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        if (comTypeDict.ContainsKey(type.ToDisplayString()))
        {
            return comTypeDict[type.ToDisplayString()].ClassCfg(_symbols);
        }

        return null;
    }

    public string GenerateClass(INamedTypeSymbol type, AutoGenerateDtoAttribute classAttr,
        Dictionary<string, INamedTypeSymbol> comTypeDict,
        bool addGeneric)
    {
        var comName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, false);
        var comInterfaceName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, true);
        var genericParams = addGeneric ? DtoGenerationSymbols.GetGenericTypeParameters(type) : "";
        var comCompatible = classAttr.IsComCompatible;

        var genericConstraints = type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, comTypeDict);
        classAttr.BaseType ??= _config.BaseType;
        var baseTypeStr = !string.IsNullOrEmpty(classAttr.BaseType) ? $"{classAttr.BaseType}, " : "";

        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf($"\t[ComVisible(true)]", comCompatible);
        if (comCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendAttributesIf(type, classAttr?.KeepAttributesOnGeneratedClass ?? false);
        sb.AppendLineIf(classAttr.PreClassString, !string.IsNullOrEmpty(classAttr.PreClassString));
        sb.AppendLine($"\t{classAttr.ClassModifier.ToCSharpKeyword()} {(_config.GeneratePartial ? "partial " : "")}class {comName}{genericParams} : {baseTypeStr}{comInterfaceName}{genericParams} {genericConstraints}");
        sb.AppendLine("\t{");
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.PropertyCfg(_symbols);
            var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, comTypeDict, _symbols, false);
            var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
            var ns = GetNamespaceForProperty(prop, comTypeDict);

            sb.AppendLine($"\t\tpublic {ns}{propTypeString} {propName} {{ get; set; }}");
        }
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propType = prop.Type;
            if (DtoGenerationSymbols.IsDtoType(propType, comTypeDict) && !DtoGenerationSymbols.IsDtoEnumType(propType, comTypeDict))
            {
                var propAttr = prop.PropertyCfg(_symbols);
                var targetClass = comTypeDict[propType.ToDisplayString()];
                var targetAttr = targetClass.ClassCfg(_symbols);
                var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, comTypeDict, _symbols, false);
                var comInterfaceTypeName = DtoGenerationSymbols.GetDtoClassName(targetClass, targetAttr, true);
                var thisInterface = comInterfaceName;
                var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
                var ns = GetNamespaceForProperty(prop, comTypeDict);

                sb.AppendAttributesIf(prop, propAttr?.KeepAttributesOnGeneratedClass ?? classAttr?.KeepPropertyAttributesOnGeneratedClass ?? false, 2);
                sb.AppendLineIf(propAttr?.PreClassString, !string.IsNullOrEmpty(propAttr?.PreClassString));
                sb.AppendLine($"\t\t{ns}{comInterfaceTypeName} {thisInterface}.{propName} {{ get => {propName}; set => {propName} = ({ns}{propTypeString})value; }}");
            }
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }


    public DtoGeneratedFile GenerateComIdFile(IEnumerable<INamedTypeSymbol> allTypes)
    {
        if (!_comIds.Any())
            return null;

        var ns = Namespace;
        var usings = new[] { "System" };
        var sb = new StringBuilder();
        sb.AppendFileHeader();
        sb.AppendUsings(usings);
        sb.OpenNamespace(ns);
        sb.AppendLine(GenerateGuids());
        sb.CloseNamespace();

        var fileName = $"{_config.ComIdClassName}.g.cs";
        return new DtoGeneratedFile(fileName, ns, sb.ToString(), usings);
    }

    public (string Id, string ClassName) GetGuid(string className)
    {
        if (!_comIds.TryGetValue(className, out var guid))
        {
            guid = Guid.NewGuid().ToString();
            _comIds[className] = guid;
        }
        return (guid, $"{Namespace}.{_config.ComIdClassName}.{string.Format(_config.ComIdClassPropertyFormat, className)}");
    }

    private string Namespace => _config?.Namespace ?? "TODO: DEFAULT"; // TODO: Default Namespace
}
