using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Nextended.Core.Attributes;
using Nextended.CodeGen.Config;
using Nextended.CodeGen.Helper;
using System.Text;
using Nextended.CodeGen.Contracts;
using Nextended.Core.Enums;

namespace Nextended.CodeGen.Generators.DtoGeneration;

public class DtoCodeGenerator
{
    private readonly DtoGenerationConfig _config;
    private readonly DtoGenerationSymbols _symbols;
    private readonly Dictionary<string, string> _comIds = new();

    public DtoCodeGenerator(DtoGenerationConfig config, DtoGenerationSymbols symbols)
    {
        _config = config;
        _symbols = symbols;
    }

    public bool HasGuids => _comIds.Any();

    /// <summary>
    /// Hauptmethode für die Dateierzeugung zu einem Typ (für OneFilePerClass = true).
    /// </summary>
    public GeneratedFile GenerateAllForType(INamedTypeSymbol type, List<INamedTypeSymbol> allTypes)
    {
        var autoGenAttr = type.ClassCfg(_symbols);
        var ns = Namespace(type);
        var dtoTypeDict = allTypes.ToDictionary(t => t.ToDisplayString(), t => t);

        var fileName = $"{DtoGenerationSymbols.GetDtoClassName(type, autoGenAttr, false)}.g.cs";
        var usings = DtoGenerationSymbols.GetUsings(type, dtoTypeDict, autoGenAttr, _config);

        var sb = new StringBuilder();

        sb.AppendFileHeaderIf(_config.CreateFileHeaders, fileName)
            .AppendUsings(usings);
        using (new NamespaceScope(sb, ns))
        {
            GenerateType(type, sb, autoGenAttr, dtoTypeDict);
        }

        return new GeneratedFile(fileName, ns, sb.ToString(), _config);
    }

    /// <summary>
    /// Methode für OneFilePerClass == false. Generiert eine Datei für alle Typen eines Namespaces.
    /// </summary>
    public GeneratedFile GenerateNamespaceFile(string ns, IEnumerable<INamedTypeSymbol> types, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        var usings = DtoGenerationSymbols.GetUsings(types, dtoTypeDict, null, _config);

        var sb = new StringBuilder();
        sb.AppendFileHeaderIf(_config.CreateFileHeaders)
            .AppendUsings(usings);

        using (new NamespaceScope(sb, ns))
        {
            foreach (var type in types)
            {
                var autoGenAttr = type.ClassCfg(_symbols);
                GenerateType(type, sb, autoGenAttr, dtoTypeDict);
            }
        }

        var fileName = $"{ns}.AllDtos.g.cs";
        return new GeneratedFile(fileName, ns, sb.ToString(), _config);
    }

    private void GenerateType(INamedTypeSymbol type, StringBuilder sb, AutoGenerateDtoAttribute autoGenAttr, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        var regionName = DtoGenerationSymbols.RegionNameFor(type, autoGenAttr);
        sb.OpenRegion(regionName, _config.CreateRegions);

        if (type.TypeKind == TypeKind.Enum)
        {
            sb.AppendLine(GenerateEnum(type, autoGenAttr, dtoTypeDict));
        }
        else
        {
            sb.AppendLine(GenerateInterface(type, autoGenAttr, dtoTypeDict, true));
            sb.AppendLine(GenerateClass(type, autoGenAttr, dtoTypeDict, true));
        }
        sb.CloseRegion(regionName, _config.CreateRegions);
    }

    private (string Result, bool ClassMapperUsed) GeneratePropertyMappingAssignment(
     IPropertySymbol prop,
     Dictionary<string, INamedTypeSymbol> dtoTypeDict,
     bool reverse)
    {
        var propAttr = prop.PropertyCfg(_symbols);
        var netPropName = prop.Name;
        var comPropName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
        var netPropType = prop.Type;

        var targetName = !reverse ? comPropName : netPropName; // Ziel-Property (dest)
        var sourceName = !reverse ? netPropName : comPropName; // Quell-Property (src)
        var mapWithClassMapper = propAttr?.MapWithClassMapper ?? false;

        // ------------------------------
        // Lokale Helfer
        // ------------------------------

        static ITypeSymbol Normalize(ITypeSymbol t) => DtoGenerationSymbols.NormalizeForLookup(t);

        (string Line, bool Used) MapAssign(string dst, string src, ITypeSymbol type, bool toNet, bool isNullable)
        {
            var targetType = DtoGenerationSymbols.BuildMappingTargetTypeString(type, toNet, dtoTypeDict, _symbols);
            var expr = isNullable ? $"{src}?.MapTo<{targetType}>()" : $"{src}.MapTo<{targetType}>()";
            return ($"\t\t\t{dst} = {expr};", true);
        }

        // Bestimme (falls vorhanden) die "spezifische" Einzel-Mapper-Methode (z. B. ToMegaDto / AsSrc)
        string GetSpecificSingleMapMethod(ITypeSymbol type, bool toDto)
        {
            var u = Normalize(type);
            var key = u.ToDisplayString();
            if (!dtoTypeDict.TryGetValue(key, out var targetClass))
                return null;

            var cfg = targetClass.ClassCfg(_symbols);
            return toDto
                ? DtoGenerationSymbols.GetToDtoMethodName(targetClass, cfg)
                : DtoGenerationSymbols.GetToSourceMethodName(targetClass, cfg);
        }

        // ------------------------------
        // 1) Enums (nullable-handling wie gehabt)
        // ------------------------------
        if (DtoGenerationSymbols.IsDtoEnumType(netPropType, dtoTypeDict))
        {
            var line = !reverse
                ? (prop.IsNullable()
                    ? $"\t\t\tresult.{targetName} = src.{sourceName}?.ToDto();"
                    : $"\t\t\tresult.{targetName} = src.{sourceName}.ToDto();")
                : (prop.IsNullable()
                    ? $"\t\t\tresult.{targetName} = src.{sourceName}?.AsEntity();"
                    : $"\t\t\tresult.{targetName} = src.{sourceName}.AsEntity();");

            return (line, false);
        }

        // ------------------------------
        // 2) Skalarer DTO-Typ (nicht generisch, kein Array)
        // ------------------------------
        if (DtoGenerationSymbols.IsDtoType(netPropType, dtoTypeDict)
            && (netPropType is not INamedTypeSymbol ng1 || !(ng1.IsGenericType))
            && netPropType is not IArrayTypeSymbol)
        {
            if (!mapWithClassMapper)
            {
                // "Spezifische" Methode versuchen
                var method = !reverse
                    ? GetSpecificSingleMapMethod(netPropType, toDto: true)
                    : GetSpecificSingleMapMethod(netPropType, toDto: false);

                if (!string.IsNullOrEmpty(method))
                {
                    var line = prop.IsNullable()
                        ? $"\t\t\tresult.{targetName} = src.{sourceName}?.{method}();"
                        : $"\t\t\tresult.{targetName} = src.{sourceName}.{method}();";
                    return (line, false);
                }
            }

            // Fallback: ClassMapper (erzwungen) oder keine spezielle Methode verfügbar
            return MapAssign($"result.{targetName}", $"src.{sourceName}", netPropType, reverse, prop.IsNullable());
        }

        // ------------------------------
        // 3) Arrays
        // ------------------------------
        if (netPropType is IArrayTypeSymbol arr)
        {
            var elem = arr.ElementType;
            var src = $"src.{sourceName}";
            var dst = $"result.{targetName}";

            if (!mapWithClassMapper && (DtoGenerationSymbols.IsDtoType(elem, dtoTypeDict) || DtoGenerationSymbols.IsDtoEnumType(elem, dtoTypeDict)))
            {
                var meth = !reverse
                    ? GetSpecificSingleMapMethod(elem, toDto: true)
                    : GetSpecificSingleMapMethod(elem, toDto: false);

                if (!string.IsNullOrEmpty(meth))
                {
                    var body = $"System.Linq.Enumerable.ToArray(System.Linq.Enumerable.Select({src}, x => x?.{meth}()))";
                    // Arrays: (unverändert) nur bei nullable Property mit Null-Check
                    var line = prop.IsNullable()
                        ? $"\t\t\t{dst} = {src} != null ? {body} : null;"
                        : $"\t\t\t{dst} = {body};";
                    return (line, false);
                }
            }

            // Fallback MapTo<T[]> (unverändert)
            return MapAssign($"result.{targetName}", $"src.{sourceName}", netPropType, reverse, prop.IsNullable());
        }

        // ------------------------------
        // 4) Generische Typen
        // ------------------------------
        if (netPropType is INamedTypeSymbol nts && nts.IsGenericType)
        {
            // 4a) Sonderfall: Nullable<T> (Value Type)
            if (nts.ConstructedFrom?.SpecialType == SpecialType.System_Nullable_T && nts.TypeArguments.Length == 1)
            {
                var underlying = nts.TypeArguments[0];

                // Wenn kein DTO/DTO-Enum und kein ClassMapper erzwungen -> direkte Zuweisung
                if (!mapWithClassMapper
                    && !DtoGenerationSymbols.IsDtoType(underlying, dtoTypeDict)
                    && !DtoGenerationSymbols.IsDtoEnumType(underlying, dtoTypeDict))
                {
                    return ($"\t\t\tresult.{targetName} = src.{sourceName};", false);
                }
                // (DTO-Enums sind bereits oben abgedeckt; übrige Fälle laufen weiter)
            }

            // 4b) Dictionary/IDictionary
            if (DtoGenerationSymbols.IsDictionaryType(nts) && nts.TypeArguments.Length == 2)
            {
                var v = nts.TypeArguments[1];
                var src = $"src.{sourceName}";
                var dst = $"result.{targetName}";

                if (!mapWithClassMapper && (DtoGenerationSymbols.IsDtoType(v, dtoTypeDict) || DtoGenerationSymbols.IsDtoEnumType(v, dtoTypeDict)))
                {
                    var meth = !reverse
                        ? GetSpecificSingleMapMethod(v, toDto: true)
                        : GetSpecificSingleMapMethod(v, toDto: false);

                    if (!string.IsNullOrEmpty(meth))
                    {
                        var body = $"System.Linq.Enumerable.ToDictionary({src}, kv => kv.Key, kv => kv.Value?.{meth}())";
                        // NEU: Immer Null-Check auf die gesamte Quelle, nicht nur bei nullable Property
                        var line = $"\t\t\t{dst} = {src} != null ? {body} : null;";
                        return (line, false);
                    }
                }

                // Fallback MapTo<Dictionary<...>> – NEU: immer mit Null-Conditional (?.)
                return MapAssign($"result.{targetName}", $"src.{sourceName}", netPropType, reverse, /*isNullable:*/ true);
            }

            // 4c) Einfache Enumerables (List, IEnumerable, ICollection, IList, IReadOnly*, HashSet)
            if (DtoGenerationSymbols.IsSimpleEnumerableType(nts) && nts.TypeArguments.Length == 1)
            {
                var elem = nts.TypeArguments[0];
                var src = $"src.{sourceName}";
                var dst = $"result.{targetName}";

                if (!mapWithClassMapper && (DtoGenerationSymbols.IsDtoType(elem, dtoTypeDict) || DtoGenerationSymbols.IsDtoEnumType(elem, dtoTypeDict)))
                {
                    var meth = !reverse
                        ? GetSpecificSingleMapMethod(elem, toDto: true)
                        : GetSpecificSingleMapMethod(elem, toDto: false);

                    if (!string.IsNullOrEmpty(meth))
                    {
                        var bodyInner = $"System.Linq.Enumerable.Select({src}, x => x?.{meth}())";
                        var body = $"System.Linq.Enumerable.ToList({bodyInner})";
                        // NEU: Immer Null-Check auf die gesamte Quelle, nicht nur bei nullable Property
                        var line = $"\t\t\t{dst} = {src} != null ? {body} : null;";
                        return (line, false);
                    }
                }

                // Fallback MapTo<List<...>> etc. – NEU: immer mit Null-Conditional (?.)
                return MapAssign($"result.{targetName}", $"src.{sourceName}", netPropType, reverse, /*isNullable:*/ true);
            }

            // 4d) Sonstige generische Typen -> Fallback MapTo<...>
            return MapAssign($"result.{targetName}", $"src.{sourceName}", netPropType, reverse, prop.IsNullable());
        }

        // ------------------------------
        // 5) Default: direkte Zuweisung (z. B. string, int, etc.)
        // ------------------------------
        return ($"\t\t\tresult.{targetName} = src.{sourceName};", false);
    }

    public GeneratedFile? GenerateMappingExtensions(List<INamedTypeSymbol> types)
    {
        bool atLeastOneGenerated = false;
        bool classMapperUsed = false;

        if (types == null || !types.Any())
            return null;

        types = types.OrderBy(s => s.Name).ToList();
        // Konfig-Schalter (falls nicht vorhanden, Defaults/Backfills)
        var generateToForAbstract = _config?.GenerateToMethodsForAbstract ?? false;
        var generateFactoryForAbstract = _config?.GenerateFactoryOverloadsForAbstract ?? true;
        var alwaysGenerateFactory = _config?.AlwaysGenerateFactoryOverloads ?? false;

        var ns = Namespace(null);
        var sb = new StringBuilder();

        using (new ClassScope(sb, _config?.CreateFileHeaders ?? true, "MappingExtensions", ns))
        {
            var dtoTypeDict = types.ToDictionary(t => t.ToDisplayString(), t => t);

            // 1) Mapping-Methoden pro Typ
            foreach (var type in types)
            {
                var autoGenAttr = type.ClassCfg(_symbols);
                if (!autoGenAttr.GenerateMapping)
                    continue;

                atLeastOneGenerated = true;

                var toDtoMethod = DtoGenerationSymbols.GetToDtoMethodName(type, autoGenAttr);
                var toNetMethod = DtoGenerationSymbols.GetToSourceMethodName(type, autoGenAttr);
                var isEnum = type.TypeKind == TypeKind.Enum;
                var isAbstract = type.IsAbstract;
                var netTypeName = type.ToDisplayString();
                var dtoTypeName = DtoGenerationSymbols.GetDtoClassName(type, autoGenAttr, false);
                var comTypeNs = !string.IsNullOrWhiteSpace(autoGenAttr.Namespace) ? $"{autoGenAttr.Namespace}." : string.Empty;
                var genericParams = DtoGenerationSymbols.GetGenericTypeParameters(type); // "<T, T2>" oder ""
                var genericConstr = type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, dtoTypeDict);

                // === Enums: unverändert ===
                if (isEnum)
                {
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName}? {toDtoMethod}(this {netTypeName}? src) => src.HasValue ? ({comTypeNs}{dtoTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName}? {toNetMethod}(this {comTypeNs}{dtoTypeName}? src) => src.HasValue ? ({netTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName} {toDtoMethod}(this {netTypeName} src) => ({comTypeNs}{dtoTypeName})(int)src;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethod}(this {comTypeNs}{dtoTypeName} src) => ({netTypeName})(int)src;");
                    continue;
                }

                var comProps = DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore).ToList();
                var baseType = type.BaseType;

                // === AssignTo: Net -> DTO ===
                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static void AssignTo{genericParams}(this {netTypeName} src, {comTypeNs}{dtoTypeName}{genericParams} dest) {genericConstr}");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif (src == null || dest == null) return;");

                // Basismapping (Net -> DTO) via Base.AssignTo<...>(...)
                if (baseType != null && dtoTypeDict.TryGetValue(baseType.ToDisplayString(), out var baseTypeSymbol))
                {
                    var baseAutoGenAttr = baseTypeSymbol.ClassCfg(_symbols);
                    if (baseAutoGenAttr != null)
                    {
                        var baseDtoName = DtoGenerationSymbols.GetDtoClassName(baseType, baseAutoGenAttr, false); // ohne Generics
                        var baseNetName = baseType.ToDisplayString(); // inkl. Generics (z. B. CodeGenSample.Entities.GenericBaseClass<T>)

                        // Generische Argumente der Basis (z. B. "<T>" / "<int>")
                        string baseGenericArgs = "";
                        if (baseType.IsGenericType && baseType.TypeArguments.Length > 0)
                        {
                            baseGenericArgs = "<" + string.Join(", ",
                                baseType.TypeArguments.Select(a => a.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat))) + ">";
                        }
                        else
                        {
                            baseGenericArgs = DtoGenerationSymbols.GetGenericTypeParameters(baseType);
                        }

                        // AssignTo mit Methodengenerics aufrufen, falls vorhanden
                        var callGen = string.IsNullOrEmpty(genericParams) ? "" : genericParams;
                        sb.AppendLine($"\t\t\t(({baseNetName})src).AssignTo{callGen}(( {baseDtoName}{baseGenericArgs} )dest);");
                    }
                }

                // Eigene Properties (Net -> DTO)
                foreach (var prop in comProps.Where(prop => !_symbols.PropertyInBaseType(prop, type.BaseType, dtoTypeDict)))
                {
                    var m = GeneratePropertyMappingAssignment(prop, dtoTypeDict, reverse: false);
                    classMapperUsed = classMapperUsed || m.ClassMapperUsed;
                    sb.AppendLine(m.Result.Replace("result.", "dest."));
                }
                sb.AppendLine("\t\t}");

                // === AssignTo: DTO -> Net ===
                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static void AssignTo{genericParams}(this {comTypeNs}{dtoTypeName}{genericParams} src, {netTypeName} dest) {genericConstr}");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif (src == null || dest == null) return;");

                // Basismapping (DTO -> Net) via Base.AssignTo<...>(...)
                if (baseType != null && dtoTypeDict.TryGetValue(baseType.ToDisplayString(), out var baseTypeSymbol2))
                {
                    var baseAutoGenAttr2 = baseTypeSymbol2.ClassCfg(_symbols);
                    if (baseAutoGenAttr2 != null)
                    {
                        var baseDtoName = DtoGenerationSymbols.GetDtoClassName(baseType, baseAutoGenAttr2, false); // ohne Generics
                        var baseNetName = baseType.ToDisplayString(); // inkl. Generics

                        string baseGenericArgs = "";
                        if (baseType.IsGenericType && baseType.TypeArguments.Length > 0)
                        {
                            baseGenericArgs = "<" + string.Join(", ",
                                baseType.TypeArguments.Select(a => a.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat))) + ">";
                        }
                        else
                        {
                            baseGenericArgs = DtoGenerationSymbols.GetGenericTypeParameters(baseType);
                        }

                        var callGen = string.IsNullOrEmpty(genericParams) ? "" : genericParams;
                        sb.AppendLine($"\t\t\t(({baseDtoName}{baseGenericArgs})src).AssignTo{callGen}(( {baseNetName} )dest);");
                    }
                }

                // Eigene Properties (DTO -> Net)
                foreach (var prop in comProps.Where(prop => !_symbols.PropertyInBaseType(prop, type.BaseType, dtoTypeDict)))
                {
                    var m = GeneratePropertyMappingAssignment(prop, dtoTypeDict, reverse: true);
                    classMapperUsed = classMapperUsed || m.ClassMapperUsed;
                    sb.AppendLine(m.Result.Replace("result.", "dest."));
                }
                sb.AppendLine("\t\t}");

                // === ToDto / ToNet ===
                var canGenerateNewBasedTo = !isAbstract || generateToForAbstract;

                // ToDto: new + AssignTo
                if (canGenerateNewBasedTo)
                {
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName}{genericParams} {toDtoMethod}{genericParams}(this {netTypeName} src) {genericConstr}");
                    sb.AppendLine("\t\t{");
                    sb.AppendLine("\t\t\tif (src == null) return null;");
                    sb.AppendLine($"\t\t\tvar result = new {comTypeNs}{dtoTypeName}{genericParams}();");
                    sb.AppendLine("\t\t\tsrc.AssignTo{genericParams}(result);".Replace("{genericParams}", string.IsNullOrEmpty(genericParams) ? "" : genericParams));
                    sb.AppendLine("\t\t\treturn result;");
                    sb.AppendLine("\t\t}");
                }

                // ToNet: new + AssignTo
                if (canGenerateNewBasedTo)
                {
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethod}{genericParams}(this {comTypeNs}{dtoTypeName}{genericParams} src) {genericConstr}");
                    sb.AppendLine("\t\t{");
                    sb.AppendLine("\t\t\tif (src == null) return null;");
                    sb.AppendLine($"\t\t\tvar result = new {netTypeName}();");
                    sb.AppendLine("\t\t\tsrc.AssignTo{genericParams}(result);".Replace("{genericParams}", string.IsNullOrEmpty(genericParams) ? "" : genericParams));
                    sb.AppendLine("\t\t\treturn result;");
                    sb.AppendLine("\t\t}");
                }

                // === Factory-Overloads ===
                if ((isAbstract && generateFactoryForAbstract) || alwaysGenerateFactory)
                {
                    // Net -> DTO via Factory
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName}{genericParams} {toDtoMethod}{genericParams}(this {netTypeName} src, Func<{comTypeNs}{dtoTypeName}{genericParams}> factory) {genericConstr}");
                    sb.AppendLine("\t\t{");
                    sb.AppendLine("\t\t\tif (src == null) return null;");
                    sb.AppendLine("\t\t\tvar result = factory != null ? factory() : null;");
                    sb.AppendLine("\t\t\tif (result == null) return null;");
                    sb.AppendLine("\t\t\tsrc.AssignTo{genericParams}(result);".Replace("{genericParams}", string.IsNullOrEmpty(genericParams) ? "" : genericParams));
                    sb.AppendLine("\t\t\treturn result;");
                    sb.AppendLine("\t\t}");

                    // DTO -> Net via Factory
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethod}{genericParams}(this {comTypeNs}{dtoTypeName}{genericParams} src, Func<{netTypeName}> factory) {genericConstr}");
                    sb.AppendLine("\t\t{");
                    sb.AppendLine("\t\t\tif (src == null) return null;");
                    sb.AppendLine("\t\t\tvar result = factory != null ? factory() : null;");
                    sb.AppendLine("\t\t\tif (result == null) return null;");
                    sb.AppendLine("\t\t\tsrc.AssignTo{genericParams}(result);".Replace("{genericParams}", string.IsNullOrEmpty(genericParams) ? "" : genericParams));
                    sb.AppendLine("\t\t\treturn result;");
                    sb.AppendLine("\t\t}");
                }
            }

            sb.AppendLine("\t}");
        }

        if (!atLeastOneGenerated)
            return null;

        if (classMapperUsed)
            sb.Insert(0, "using Nextended.Core.Extensions;");

        return new GeneratedFile("MappingExtensions.g.cs", ns, sb.ToString(), _config?.MappingOutputPath ?? _config?.OutputPath);
    }

    public string GenerateGuids()
    {
        if (!_comIds.Any()) return string.Empty;

        var sb = new StringBuilder();
        sb.AppendLine("\t#region ComGuids");
        sb.AppendLine($"\t{_config.ComIdClassModifier.ToCSharpKeyword()} static partial class {_config.ComIdClassName}");
        sb.AppendLine("\t{");
        foreach (var kv in _comIds)
            sb.AppendLine($"\t\tpublic const string {string.Format(_config.ComIdClassPropertyFormat, kv.Key)} = \"{kv.Value}\";");
        sb.AppendLine("\t}");
        sb.AppendLine("\t#endregion ComGuids");
        return sb.ToString();
    }

    public string GenerateEnum(INamedTypeSymbol enumType, AutoGenerateDtoAttribute classAttr, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        var comName = DtoGenerationSymbols.GetDtoClassName(enumType, classAttr, false);
        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{enumType.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf("\t[ComVisible(true)]", classAttr.IsComCompatible);
        if (classAttr.IsComCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLine($"\t{classAttr.ClassModifier.ToCSharpKeyword()} enum {comName}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>().Where(f => f.IsConst))
        {
            if (_symbols.Ignore != null && member.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, _symbols.Ignore)))
                continue;
            if (_config.CreateComments) sb.AppendLine($"\t\t/// <summary>{member.Name}</summary>");
            sb.AppendLineIf($"\t\t[DispId({++dispId})]", classAttr.IsComCompatible);
            sb.AppendLine($"\t\t{member.Name} = {member.ConstantValue},");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public string GenerateInterface(INamedTypeSymbol type,
        AutoGenerateDtoAttribute classAttr,
        Dictionary<string, INamedTypeSymbol> dtoTypeDict,
        bool addGeneric)
    {
        var comInterfaceName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, true);
        var comName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, false);
        var genericParams = addGeneric ? DtoGenerationSymbols.GetGenericTypeParameters(type) : "";
        var comCompatible = classAttr.IsComCompatible;

        var genericConstraints =
            type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, dtoTypeDict);
        classAttr.Interfaces ??= _config.Interfaces;

        var baseTypeStr = _symbols.GetBaseTypeString(type, classAttr, dtoTypeDict, true);

        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comInterfaceName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");

        sb.AppendAttributesIf(type, classAttr?.KeepAttributesOnGeneratedInterface ?? false);
        sb.AppendLineIf("\t[ComVisible(true)]", comCompatible);
        if (comCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLineIf("\t[TypeLibType(TypeLibTypeFlags.FDual | TypeLibTypeFlags.FDispatchable)]", comCompatible);
        sb.AppendLineIf(classAttr.PreInterfaceString, !string.IsNullOrEmpty(classAttr.PreInterfaceString));
        sb.AppendLine($"\t{classAttr.InterfaceModifier.ToCSharpKeyword()} {(_config.GeneratePartial ? "partial " : "")}interface {comInterfaceName}{genericParams} {baseTypeStr} {genericConstraints}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.PropertyCfg(_symbols);
            var getterSetter = DtoGenerationSymbols.ResolveInterfaceAccess(prop, classAttr, _symbols).ToCSharpKeyword();

            var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, true);
            var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);

            sb.AppendAttributesIf(prop, propAttr?.KeepAttributesOnGeneratedInterface ?? classAttr?.KeepPropertyAttributesOnGeneratedInterface ?? false, 2);
            sb.AppendLineIf(propAttr?.PreInterfaceString, !string.IsNullOrEmpty(propAttr?.PreInterfaceString));

            sb.AppendLineIf($"\t\t[DispId({++dispId})]", comCompatible);
            var ns = _symbols.GetNamespaceForProperty(prop, dtoTypeDict);
            sb.AppendLine($"\t\t{ns}{propTypeString} {propName} {{ {getterSetter} }}");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public string GenerateClass(INamedTypeSymbol type, AutoGenerateDtoAttribute classAttr,
        Dictionary<string, INamedTypeSymbol> dtoTypeDict,
        bool addGeneric)
    {
        var comName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, false);
        var comInterfaceName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, true);
        var genericParams = addGeneric ? DtoGenerationSymbols.GetGenericTypeParameters(type) : "";
        var comCompatible = classAttr.IsComCompatible;

        var genericConstraints = type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, dtoTypeDict);

        var baseTypeStr = _symbols.GetBaseTypeString(type, [], dtoTypeDict, false)?.Replace(":", "");
        if (string.IsNullOrWhiteSpace(baseTypeStr))
            baseTypeStr = classAttr.BaseType ??= _config.BaseType;
        baseTypeStr = !string.IsNullOrEmpty(baseTypeStr) ? $"{baseTypeStr}, " : "";

        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf($"\t[ComVisible(true)]", comCompatible);
        if (comCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendAttributesIf(type, classAttr?.KeepAttributesOnGeneratedClass ?? false);
        sb.AppendLineIf(classAttr.PreClassString, !string.IsNullOrEmpty(classAttr.PreClassString));
        var modelType = _config.ModelType; // TODO: class attr cfg
        var abstractPrefix = (_config.MakeDtoAbstractWhenSourceIsAbstract && type.IsAbstract) ? "abstract " : "";

        sb.AppendLine($"\t{classAttr.ClassModifier.ToCSharpKeyword()} {abstractPrefix}{(_config.GeneratePartial ? "partial " : "")}{modelType.ToCSharpKeyword()} {comName}{genericParams} : {baseTypeStr}{comInterfaceName}{genericParams} {genericConstraints}");
        sb.AppendLine("\t{");
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.PropertyCfg(_symbols);
            var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, false);
            var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
            var ns = _symbols.GetNamespaceForProperty(prop, dtoTypeDict);

            sb.AppendLine($"\t\tpublic {ns}{propTypeString} {propName} {{ get; set; }}");
        }
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propType = prop.Type;

            if (DtoGenerationSymbols.IsDtoType(propType, dtoTypeDict) && !DtoGenerationSymbols.IsDtoEnumType(propType, dtoTypeDict))
            {
                var propAttr = prop.PropertyCfg(_symbols);

                var targetClass = dtoTypeDict.ContainsKey(propType.ToDisplayString()) ? dtoTypeDict[propType.ToDisplayString()] : dtoTypeDict[DtoGenerationSymbols.NormalizeForLookup(propType).ToDisplayString()];
                var targetAttr = targetClass.ClassCfg(_symbols);
                var interfaceAccess = DtoGenerationSymbols.ResolveInterfaceAccess(prop, classAttr, _symbols);

                var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, false);
                var comInterfaceTypeName = DtoGenerationSymbols.GetDtoClassName(targetClass, targetAttr, true);
                var thisInterface = comInterfaceName;
                var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
                var ns = _symbols.GetNamespaceForProperty(prop, dtoTypeDict);

                sb.AppendAttributesIf(prop, propAttr?.KeepAttributesOnGeneratedClass ?? classAttr?.KeepPropertyAttributesOnGeneratedClass ?? false, 2);
                sb.AppendLineIf(propAttr?.PreClassString, !string.IsNullOrEmpty(propAttr?.PreClassString));
                // Explicit interface implementation for properties of DTOs
                var castType = DtoGenerationSymbols.TrimNullableSuffix(propTypeString);
                if (interfaceAccess is InterfaceProperty.GetAndSet or InterfaceProperty.Unset)
                    sb.AppendLine($"\t\t{ns}{comInterfaceTypeName} {thisInterface}.{propName} {{ get => {propName}; set => {propName} = ({ns}{castType})value; }}");
                else if (interfaceAccess == InterfaceProperty.Get)
                    sb.AppendLine($"\t\t{ns}{comInterfaceTypeName} {thisInterface}.{propName} {{ get => {propName}; }}");
                else if (interfaceAccess == InterfaceProperty.Set)
                    sb.AppendLine($"\t\t{ns}{comInterfaceTypeName} {thisInterface}.{propName} {{ set => {propName} = ({ns}{castType})value; }}");
            }
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public GeneratedFile GenerateComIdFile(IEnumerable<INamedTypeSymbol> allTypes)
    {
        if (!_comIds.Any())
            return null;

        var ns = Namespace(null);
        var usings = new[] { "System" };
        var sb = new StringBuilder();
        sb.AppendFileHeaderIf(_config.CreateFileHeaders);
        sb.AppendUsings(usings);
        sb.OpenNamespace(ns);
        sb.AppendLine(GenerateGuids());
        sb.CloseNamespace();

        var fileName = $"{_config.ComIdClassName}.g.cs";
        return new GeneratedFile(fileName, ns, sb.ToString(), _config);
    }

    public (string Id, string ClassName) GetGuid(string className)
    {
        if (!_comIds.TryGetValue(className, out var guid))
        {
            guid = Guid.NewGuid().ToString();
            _comIds[className] = guid;
        }
        return (guid, $"{Namespace(null)}.{_config.ComIdClassName}.{string.Format(_config.ComIdClassPropertyFormat, className)}");
    }

    internal string Namespace(INamedTypeSymbol? type)
    {
        return _symbols.Namespace(type);
    }
}
