using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Nextended.Core.Attributes;
using Nextended.CodeGen.Config;
using Nextended.CodeGen.Helper;
using System.Text;
using Nextended.CodeGen.Contracts;
using Nextended.Core.Enums;

namespace Nextended.CodeGen.Generators.DtoGeneration;

public class DtoCodeGenerator
{
    private readonly DtoGenerationConfig _config;
    private readonly DtoGenerationSymbols _symbols;
    private readonly Dictionary<string, string> _comIds = new();

    public DtoCodeGenerator(DtoGenerationConfig config, DtoGenerationSymbols symbols)
    {
        _config = config;
        _symbols = symbols;
    }

    public bool HasGuids => _comIds.Any();

    /// <summary>
    /// Hauptmethode für die Dateierzeugung zu einem Typ (für OneFilePerClass = true).
    /// </summary>
    public GeneratedFile GenerateAllForType(INamedTypeSymbol type, List<INamedTypeSymbol> allTypes)
    {
        var autoGenAttr = type.ClassCfg(_symbols);
        var ns = Namespace(type);
        var dtoTypeDict = allTypes.ToDictionary(t => t.ToDisplayString(), t => t);

        var fileName = $"{DtoGenerationSymbols.GetDtoClassName(type, autoGenAttr, false)}.g.cs";
        var usings = DtoGenerationSymbols.GetUsings(type, dtoTypeDict, autoGenAttr, _config);

        var sb = new StringBuilder();

        sb.AppendFileHeader(fileName)
            .AppendUsings(usings);
        using (new NamespaceScope(sb, ns))
        {
            GenerateType(type, sb, autoGenAttr, dtoTypeDict);
        }

        return new GeneratedFile(fileName, ns, sb.ToString(), _config);
    }

    /// <summary>
    /// Methode für OneFilePerClass == false. Generiert eine Datei für alle Typen eines Namespaces.
    /// </summary>
    public GeneratedFile GenerateNamespaceFile(string ns, IEnumerable<INamedTypeSymbol> types, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        var usings = DtoGenerationSymbols.GetUsings(types, dtoTypeDict, null, _config);

        var sb = new StringBuilder();
        sb.AppendFileHeader()
            .AppendUsings(usings);

        using (new NamespaceScope(sb, ns))
        {
            foreach (var type in types)
            {
                var autoGenAttr = type.ClassCfg(_symbols);
                GenerateType(type, sb, autoGenAttr, dtoTypeDict);
            }
        }

        var fileName = $"{ns}.AllDtos.g.cs";
        return new GeneratedFile(fileName, ns, sb.ToString(), _config);
    }

    private void GenerateType(INamedTypeSymbol type, StringBuilder sb, AutoGenerateDtoAttribute autoGenAttr, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        var regionName = DtoGenerationSymbols.RegionNameFor(type, autoGenAttr);
        sb.OpenRegion(regionName, _config.CreateRegions);

        if (type.TypeKind == TypeKind.Enum)
        {
            sb.AppendLine(GenerateEnum(type, autoGenAttr, dtoTypeDict));
        }
        else
        {
            sb.AppendLine(GenerateInterface(type, autoGenAttr, dtoTypeDict, true));
            sb.AppendLine(GenerateClass(type, autoGenAttr, dtoTypeDict, true));
        }
        sb.CloseRegion(regionName, _config.CreateRegions);
    }

    private string GeneratePropertyMappingAssignment(IPropertySymbol prop, Dictionary<string, INamedTypeSymbol> dtoTypeDict, bool reverse)
    {
        var propAttr = prop.PropertyCfg(_symbols);

        var netPropName = prop.Name;
        var comPropName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
        var netPropType = prop.Type;

        var targetName = !reverse ? comPropName : netPropName;
        var sourceName = !reverse ? netPropName : comPropName;

        // Helper-Funktion: Liefert für reverse/source richtig den Target-Type für MapTo<>
        string GetTargetType(ITypeSymbol typeSymbol, bool reverseDir)
        {
            if (typeSymbol is INamedTypeSymbol nts)
            {
                var autoGenAttr = nts.ClassCfg(_symbols);
                return !reverseDir
                    ? $"{DtoGenerationSymbols.GetDtoClassName(nts, autoGenAttr, false)}{DtoGenerationSymbols.GetGenericTypeParameters(nts)}"
                    : nts.ToDisplayString(); // enthält generics schon
            }
            return typeSymbol.ToDisplayString();
        }

        if (DtoGenerationSymbols.IsDtoEnumType(netPropType, dtoTypeDict))
        {
            var enumType = netPropType.UnwrapNullableTypeSymbol();
            var targetClass = dtoTypeDict[enumType.ToDisplayString()];
            var targetAttr = targetClass.ClassCfg(_symbols);

            if (!targetAttr.GenerateMapping || (propAttr?.MapWithClassMapper ?? false))
            {
                var targetTypeString = GetTargetType(targetClass, reverse);
                return prop.IsNullable()
                    ? $"\t\t\tresult.{targetName} = src.{sourceName}?.MapTo<{targetTypeString}>();"
                    : $"\t\t\tresult.{targetName} = src.{sourceName}.MapTo<{targetTypeString}>();";
            }

            var enumToComMethod = !reverse
                ? DtoGenerationSymbols.GetToDtoMethodName(targetClass, targetAttr)
                : DtoGenerationSymbols.GetToSourceMethodName(targetClass, targetAttr);

            return prop.IsNullable()
                ? $"\t\t\tresult.{targetName} = src.{sourceName}?.{enumToComMethod}();"
                : $"\t\t\tresult.{targetName} = src.{sourceName}.{enumToComMethod}();";
        }

        if (DtoGenerationSymbols.IsDtoType(netPropType, dtoTypeDict))
        {
            var classType = netPropType.UnwrapNullableTypeSymbol();
            var targetClass = dtoTypeDict[classType.ToDisplayString()];
            var targetAttr = targetClass.ClassCfg(_symbols);

            if (!targetAttr.GenerateMapping || (propAttr?.MapWithClassMapper ?? false))
            {
                var targetTypeString = GetTargetType(targetClass, reverse);
                return prop.IsNullable()
                    ? $"\t\t\tresult.{targetName} = src.{sourceName}?.MapTo<{targetTypeString}>();"
                    : $"\t\t\tresult.{targetName} = src.{sourceName}.MapTo<{targetTypeString}>();";
            }

            var propToComMethod = !reverse
                ? DtoGenerationSymbols.GetToDtoMethodName(targetClass, targetAttr)
                : DtoGenerationSymbols.GetToSourceMethodName(targetClass, targetAttr);

            return $"\t\t\tresult.{targetName} = src.{sourceName}?.{propToComMethod}();";
        }
        return $"\t\t\tresult.{targetName} = src.{sourceName};";
    }

  

    public GeneratedFile? GenerateMappingExtensions(List<INamedTypeSymbol> types)
    {
        var ns = Namespace(null);
        var sb = new StringBuilder();
        var generatedBaseTypes = new HashSet<string>();
        
        using (new ClassScope(sb, "MappingExtensions", ns))
        {
            var dtoTypeDict = types.ToDictionary(t => t.ToDisplayString(), t => t);

            // 1. Hilfsmethoden pro DTO-Basistyp erzeugen
            foreach (var baseType in types.Select(type => type.BaseType))
            {
                if (baseType == null) continue;
                var baseTypeKey = baseType.ToDisplayString();
                if (generatedBaseTypes.Contains(baseTypeKey)) continue;

                if (dtoTypeDict.TryGetValue(baseTypeKey, out var baseTypeSymbol))
                {
                    var baseAutoGenAttr = baseTypeSymbol.ClassCfg(_symbols);
                    if (baseAutoGenAttr != null)
                    {
                        generatedBaseTypes.Add(baseTypeKey);

                        var baseDtoName = DtoGenerationSymbols.GetDtoClassName(baseType, baseAutoGenAttr, false);
                        var netBaseName = baseType.ToDisplayString();

                        // Hilfsmethode: Entity -> DTO
                        var baseProps = DtoGenerationSymbols.GetDtoProperties(baseType, _symbols.Ignore).ToList();
                        sb.AppendLine($"\t\tpublic static void AssignBaseProperties(this {baseDtoName} dto, {netBaseName} src)");
                        sb.AppendLine("\t\t{");
                        foreach (var prop in baseProps)
                        {
                            var propAttr = prop.PropertyCfg(_symbols);
                            var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, false);
                            var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
                            sb.AppendLine($"\t\t\tdto.{propName} = src.{prop.Name};");
                        }
                        sb.AppendLine("\t\t}");

                        // Hilfsmethode: DTO -> Entity
                        sb.AppendLine($"\t\tpublic static void AssignBaseProperties(this {netBaseName} entity, {baseDtoName} dto)");
                        sb.AppendLine("\t\t{");
                        foreach (var prop in baseProps)
                        {
                            var propAttr = prop.PropertyCfg(_symbols);
                            var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, false);
                            var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
                            sb.AppendLine($"\t\t\tentity.{prop.Name} = dto.{propName};");
                        }
                        sb.AppendLine("\t\t}");
                    }
                }
            }

            // 2. Eigentliche Mapping-Methoden
            foreach (var type in types)
            {
                var autoGenAttr = type.ClassCfg(_symbols);
                if (!autoGenAttr.GenerateMapping)
                    continue;

                var toDtoMethod = DtoGenerationSymbols.GetToDtoMethodName(type, autoGenAttr);
                var toNetMethod = DtoGenerationSymbols.GetToSourceMethodName(type, autoGenAttr);
                var isEnum = type.TypeKind == TypeKind.Enum;
                var netTypeName = type.ToDisplayString();
                var dtoTypeName = DtoGenerationSymbols.GetDtoClassName(type, autoGenAttr, false);
                var comTypeNs = !string.IsNullOrWhiteSpace(autoGenAttr.Namespace) ? $"{autoGenAttr.Namespace}." : string.Empty;
                var genericParams = DtoGenerationSymbols.GetGenericTypeParameters(type);
                var genericConstraints = type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, dtoTypeDict);

                if (isEnum)
                {
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName}? {toDtoMethod}(this {netTypeName}? src) => src.HasValue ? ({comTypeNs}{dtoTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName}? {toNetMethod}(this {comTypeNs}{dtoTypeName}? src) => src.HasValue ? ({netTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName} {toDtoMethod}(this {netTypeName} src) => ({comTypeNs}{dtoTypeName})(int)src;");
                    sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethod}(this {comTypeNs}{dtoTypeName} src) => ({netTypeName})(int)src;");
                    continue;
                }

                var comProps = DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore).ToList();

                // Forward Mapping: Source → DTO
                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {comTypeNs}{dtoTypeName}{genericParams} {toDtoMethod}{genericParams}(this {netTypeName} src) {genericConstraints}");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(src == null) return null;");
                sb.AppendLine($"\t\t\tvar result = new {comTypeNs}{dtoTypeName}{genericParams}();");

                // --- Basismapping aufrufen, falls Basisklasse mit DTO vorhanden
                var baseType = type.BaseType;
                if (baseType != null && dtoTypeDict.TryGetValue(baseType.ToDisplayString(), out var baseTypeSymbol))
                {
                    var baseAutoGenAttr = baseTypeSymbol.ClassCfg(_symbols);
                    if (baseAutoGenAttr != null)
                    {
                        var baseDtoName = DtoGenerationSymbols.GetDtoClassName(baseType, baseAutoGenAttr, false);
                        sb.AppendLine($"\t\t\t(( {baseDtoName} )result).AssignBaseProperties(src);");
                    }
                }
                
                foreach (var prop in comProps.Where(prop => !_symbols.PropertyInBaseType(prop, type.BaseType, dtoTypeDict)))
                {
                    sb.AppendLine(GeneratePropertyMappingAssignment(prop, dtoTypeDict, false));
                }

                sb.AppendLine("\t\t\treturn result;");
                sb.AppendLine("\t\t}");

                // Reverse Mapping: DTO → Source
                sb.AppendLine($"\t\t{autoGenAttr.ClassModifier.ToCSharpKeyword()} static {netTypeName} {toNetMethod}{genericParams}(this {comTypeNs}{dtoTypeName}{genericParams} src) {genericConstraints}");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(src == null) return null;");
                sb.AppendLine($"\t\t\tvar result = new {netTypeName}();");

                // --- Basismapping zurück
                if (baseType != null && dtoTypeDict.TryGetValue(baseType.ToDisplayString(), out var baseTypeSymbol2))
                {
                    var baseAutoGenAttr2 = baseTypeSymbol2.ClassCfg(_symbols);
                    if (baseAutoGenAttr2 != null)
                    {
                        var baseDtoName = DtoGenerationSymbols.GetDtoClassName(baseType, baseAutoGenAttr2, false);
                        sb.AppendLine($"\t\t\tresult.AssignBaseProperties(( {baseDtoName} )src);");
                    }
                }
                // --- Eigene Properties zurück
                foreach (var prop in comProps.Where(prop => !_symbols.PropertyInBaseType(prop, type.BaseType, dtoTypeDict)))
                {
                    sb.AppendLine(GeneratePropertyMappingAssignment(prop, dtoTypeDict, true));
                }
                sb.AppendLine("\t\t\treturn result;");
                sb.AppendLine("\t\t}");
            }
            sb.AppendLine("\t}");
        }

        return new GeneratedFile("MappingExtensions.g.cs", ns, sb.ToString(), _config);

    }




    public string GenerateGuids()
    {
        if (!_comIds.Any()) return string.Empty;

        var sb = new StringBuilder();
        sb.AppendLine("\t#region ComGuids");
        sb.AppendLine($"\t{_config.ComIdClassModifier.ToCSharpKeyword()} static partial class {_config.ComIdClassName}");
        sb.AppendLine("\t{");
        foreach (var kv in _comIds)
            sb.AppendLine($"\t\tpublic const string {string.Format(_config.ComIdClassPropertyFormat, kv.Key)} = \"{kv.Value}\";");
        sb.AppendLine("\t}");
        sb.AppendLine("\t#endregion ComGuids");
        return sb.ToString();
    }

    public string GenerateEnum(INamedTypeSymbol enumType, AutoGenerateDtoAttribute classAttr, Dictionary<string, INamedTypeSymbol> dtoTypeDict)
    {
        var comName = DtoGenerationSymbols.GetDtoClassName(enumType, classAttr, false);
        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{enumType.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf("\t[ComVisible(true)]", classAttr.IsComCompatible);
        if (classAttr.IsComCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLine($"\t{classAttr.ClassModifier.ToCSharpKeyword()} enum {comName}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>().Where(f => f.IsConst))
        {
            if (_symbols.Ignore != null && member.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, _symbols.Ignore)))
                continue;
            if (_config.CreateComments) sb.AppendLine($"\t\t/// <summary>{member.Name}</summary>");
            sb.AppendLineIf($"\t\t[DispId({++dispId})]", classAttr.IsComCompatible);
            sb.AppendLine($"\t\t{member.Name} = {member.ConstantValue},");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public string GenerateInterface(INamedTypeSymbol type,
        AutoGenerateDtoAttribute classAttr,
        Dictionary<string, INamedTypeSymbol> dtoTypeDict,
        bool addGeneric)
    {
        var comInterfaceName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, true);
        var comName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, false);
        var genericParams = addGeneric ? DtoGenerationSymbols.GetGenericTypeParameters(type) : "";
        var comCompatible = classAttr.IsComCompatible;

        var genericConstraints =
            type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, dtoTypeDict);
        classAttr.Interfaces ??= _config.Interfaces;

        var baseTypeStr = _symbols.GetBaseTypeString(type, classAttr, dtoTypeDict, true);

        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comInterfaceName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");

        sb.AppendAttributesIf(type, classAttr?.KeepAttributesOnGeneratedInterface ?? false);
        sb.AppendLineIf("\t[ComVisible(true)]", comCompatible);
        if (comCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLineIf("\t[TypeLibType(TypeLibTypeFlags.FDual | TypeLibTypeFlags.FDispatchable)]", comCompatible);
        sb.AppendLineIf(classAttr.PreInterfaceString, !string.IsNullOrEmpty(classAttr.PreInterfaceString));
        sb.AppendLine($"\t{classAttr.InterfaceModifier.ToCSharpKeyword()} {(_config.GeneratePartial ? "partial " : "")}interface {comInterfaceName}{genericParams} {baseTypeStr} {genericConstraints}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.PropertyCfg(_symbols);
            var getterSetter = (propAttr?.InterfaceAccess ?? classAttr.DefaultPropertyInterfaceAccess).ToCSharpKeyword();
            var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, true);
            var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);

            sb.AppendAttributesIf(prop, propAttr?.KeepAttributesOnGeneratedInterface ?? classAttr?.KeepPropertyAttributesOnGeneratedInterface ?? false, 2);
            sb.AppendLineIf(propAttr?.PreInterfaceString, !string.IsNullOrEmpty(propAttr?.PreInterfaceString));

            sb.AppendLineIf($"\t\t[DispId({++dispId})]", comCompatible);
            var ns = _symbols.GetNamespaceForProperty(prop, dtoTypeDict);
            sb.AppendLine($"\t\t{ns}{propTypeString} {propName} {{ {getterSetter} }}");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public string GenerateClass(INamedTypeSymbol type, AutoGenerateDtoAttribute classAttr,
        Dictionary<string, INamedTypeSymbol> dtoTypeDict,
        bool addGeneric)
    {
        var comName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, false);
        var comInterfaceName = DtoGenerationSymbols.GetDtoClassName(type, classAttr, true);
        var genericParams = addGeneric ? DtoGenerationSymbols.GetGenericTypeParameters(type) : "";
        var comCompatible = classAttr.IsComCompatible;

        var genericConstraints = type.GenerateGenericConstraintsWithDtoSubstitution(_symbols.AutoGenerateDto, dtoTypeDict);
        
        var baseTypeStr = _symbols.GetBaseTypeString(type, [], dtoTypeDict, false)?.Replace(":", "");
        if (string.IsNullOrWhiteSpace(baseTypeStr))
            baseTypeStr = classAttr.BaseType ??= _config.BaseType;
        baseTypeStr = !string.IsNullOrEmpty(baseTypeStr) ? $"{baseTypeStr}, " : "";

        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf($"\t[ComVisible(true)]", comCompatible);
        if (comCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendAttributesIf(type, classAttr?.KeepAttributesOnGeneratedClass ?? false);
        sb.AppendLineIf(classAttr.PreClassString, !string.IsNullOrEmpty(classAttr.PreClassString));
        var modelType = _config.ModelType; // TODO: class attr cfg
        sb.AppendLine($"\t{classAttr.ClassModifier.ToCSharpKeyword()} {(_config.GeneratePartial ? "partial " : "")}{modelType.ToCSharpKeyword()} {comName}{genericParams} : {baseTypeStr}{comInterfaceName}{genericParams} {genericConstraints}");
        sb.AppendLine("\t{");
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.PropertyCfg(_symbols);
            var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, false);
            var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
            var ns = _symbols.GetNamespaceForProperty(prop, dtoTypeDict);

            sb.AppendLine($"\t\tpublic {ns}{propTypeString} {propName} {{ get; set; }}");
        }
        foreach (var prop in DtoGenerationSymbols.GetDtoProperties(type, _symbols.Ignore))
        {
            var propType = prop.Type;
            if (DtoGenerationSymbols.IsDtoType(propType, dtoTypeDict) && !DtoGenerationSymbols.IsDtoEnumType(propType, dtoTypeDict))
            {
                var propAttr = prop.PropertyCfg(_symbols);
                var targetClass = dtoTypeDict[propType.ToDisplayString()];
                var targetAttr = targetClass.ClassCfg(_symbols);
                var propTypeString = DtoGenerationSymbols.GetDtoPropertyType(prop, dtoTypeDict, _symbols, false);
                var comInterfaceTypeName = DtoGenerationSymbols.GetDtoClassName(targetClass, targetAttr, true);
                var thisInterface = comInterfaceName;
                var propName = DtoGenerationSymbols.GetDtoPropertyName(prop, propAttr);
                var ns = _symbols.GetNamespaceForProperty(prop, dtoTypeDict);

                sb.AppendAttributesIf(prop, propAttr?.KeepAttributesOnGeneratedClass ?? classAttr?.KeepPropertyAttributesOnGeneratedClass ?? false, 2);
                sb.AppendLineIf(propAttr?.PreClassString, !string.IsNullOrEmpty(propAttr?.PreClassString));
                sb.AppendLine($"\t\t{ns}{comInterfaceTypeName} {thisInterface}.{propName} {{ get => {propName}; set => {propName} = ({ns}{propTypeString})value; }}");
            }
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }


    public GeneratedFile GenerateComIdFile(IEnumerable<INamedTypeSymbol> allTypes)
    {
        if (!_comIds.Any())
            return null;

        var ns = Namespace(null);
        var usings = new[] { "System" };
        var sb = new StringBuilder();
        sb.AppendFileHeader();
        sb.AppendUsings(usings);
        sb.OpenNamespace(ns);
        sb.AppendLine(GenerateGuids());
        sb.CloseNamespace();

        var fileName = $"{_config.ComIdClassName}.g.cs";
        return new GeneratedFile(fileName, ns, sb.ToString(), _config);
    }

    public (string Id, string ClassName) GetGuid(string className)
    {
        if (!_comIds.TryGetValue(className, out var guid))
        {
            guid = Guid.NewGuid().ToString();
            _comIds[className] = guid;
        }
        return (guid, $"{Namespace(null)}.{_config.ComIdClassName}.{string.Format(_config.ComIdClassPropertyFormat, className)}");
    }

    internal string Namespace(INamedTypeSymbol? type)
    {
        return _symbols.Namespace(type);
    }
}
