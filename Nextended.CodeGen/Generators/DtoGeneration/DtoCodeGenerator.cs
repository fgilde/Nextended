using Microsoft.CodeAnalysis;
using Nextended.CodeGen.Attributes;
using Nextended.CodeGen.Config;
using Nextended.CodeGen.Helper;
using System.Text;

namespace Nextended.CodeGen.Generators.DtoGeneration;

public class DtoCodeGenerator
{
    private readonly DtoGenerationConfig _config;
    private readonly DtoGenerationSymbols _symbols;
    private readonly Dictionary<string, string> _comIds = new();

    public DtoCodeGenerator(DtoGenerationConfig config, DtoGenerationSymbols symbols)
    {
        _config = config;
        _symbols = symbols;
    }

    public bool HasGuids => _comIds.Any();

    /// <summary>
    /// Hauptmethode für die Dateierzeugung zu einem Typ (für OneFilePerClass = true).
    /// </summary>
    public DtoGeneratedFile GenerateAllForType(INamedTypeSymbol type, List<INamedTypeSymbol> allTypes)
    {
        var autoGenAttr = type.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);
        var ns = autoGenAttr?.Namespace ?? _config.Namespace;
        var comTypeDict = allTypes.ToDictionary(t => t.ToDisplayString(), t => t);

        var fileName = $"{DtoGenerationSymbols.GetComClassName(type, autoGenAttr, false)}.g.cs";
        var usings = DtoGenerationSymbols.GetUsings(type, comTypeDict, autoGenAttr, _config);

        var sb = new StringBuilder();

        sb.AppendFileHeader(fileName)
            .AppendUsings(usings);
        using (new NamespaceScope(sb, ns))
        {
            GenerateType(type, sb, autoGenAttr, comTypeDict);
        }

        return new DtoGeneratedFile(fileName, ns, sb.ToString(), usings);
    }

    /// <summary>
    /// Methode für OneFilePerClass == false. Generiert eine Datei für alle Typen eines Namespaces.
    /// </summary>
    public DtoGeneratedFile GenerateNamespaceFile(string ns, IEnumerable<INamedTypeSymbol> types, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        var usings = DtoGenerationSymbols.GetUsings(types, comTypeDict, null, _config);

        var sb = new StringBuilder();
        sb.AppendFileHeader()
            .AppendUsings(usings);            
        
        using (new NamespaceScope(sb, ns))
        {
            foreach (var type in types)
            {
                var autoGenAttr = type.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);
                GenerateType(type, sb, autoGenAttr, comTypeDict);
            }
        }

        var fileName = $"{ns}.AllDtos.g.cs";
        return new DtoGeneratedFile(fileName, ns, sb.ToString(), usings);
    }

    private void GenerateType(INamedTypeSymbol type, StringBuilder sb, AutoGenerateDtoAttribute autoGenAttr, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        var regionName = DtoGenerationSymbols.RegionNameFor(type, autoGenAttr);
        sb.OpenRegion(regionName, _config.CreateRegions);

        if (type.TypeKind == TypeKind.Enum)
        {
            sb.AppendLine(GenerateEnum(type, autoGenAttr, comTypeDict));
        }
        else
        {
            sb.AppendLine(GenerateInterface(type, autoGenAttr, comTypeDict, true));
            sb.AppendLine(GenerateClass(type, autoGenAttr, comTypeDict, true));
        }
        sb.CloseRegion(regionName, _config.CreateRegions);
    }

    public DtoGeneratedFile? GenerateMappingExtensions(List<INamedTypeSymbol> types)
    {
        //if (!_config.GenerateMappingExtensions)
        //    return null;

        var ns = _config.Namespace;
        var sb = new StringBuilder();

        using (new ClassScope(sb, "MappingExtensions", ns))
        {
            var comTypeDict = types.ToDictionary(t => t.ToDisplayString(), t => t);

            foreach (var type in types)
            {
                var autoGenAttr = type.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);

                var toComMethodName = DtoGenerationSymbols.GetToComMethodName(type, autoGenAttr);
                var isEnum = type.TypeKind == TypeKind.Enum;
                var netTypeName = type.ToDisplayString();
                var comTypeName = DtoGenerationSymbols.GetComClassName(type, autoGenAttr, false);

                var genericParams = DtoGenerationSymbols.GetGenericTypeParameters(type);
                var genericConstraints = string.Join(" ", type.TypeParameters.Select(tp => tp.ConstraintClause())); // Optional: Constraints

                if (isEnum)
                {
                    sb.AppendLine($"\t\tpublic static {comTypeName}? {toComMethodName}(this {netTypeName}? src) => src.HasValue ? ({comTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\tpublic static {netTypeName}? ToNet(this {comTypeName}? src) => src.HasValue ? ({netTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\tpublic static {comTypeName} {toComMethodName}(this {netTypeName} src) => ({comTypeName})(int)src;");
                    sb.AppendLine($"\t\tpublic static {netTypeName} ToNet(this {comTypeName} src) => ({netTypeName})(int)src;");
                    continue;
                }

                var comProps = DtoGenerationSymbols.GetComProperties(type, _symbols.Ignore).ToList();

                sb.AppendLine($"\t\tpublic static {comTypeName}{genericParams} {toComMethodName}{genericParams}(this {netTypeName} src)");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(src == null) return null;");
                sb.AppendLine($"\t\t\tvar result = new {comTypeName}{genericParams}();");
                foreach (var prop in comProps)
                {
                    var propAttr = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(_symbols.PropertySetting);
                    var netPropName = prop.Name;
                    var comPropName = DtoGenerationSymbols.GetComPropertyName(prop, propAttr);
                    var netPropType = prop.Type;

                    if (DtoGenerationSymbols.IsComEnumType(netPropType, comTypeDict))
                    {
                        var enumType = netPropType.UnwrapNullableTypeSymbol();
                        var targetClass = comTypeDict[enumType.ToDisplayString()];
                        var targetAttr = targetClass.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);
                        var enumToComMethod = DtoGenerationSymbols.GetToComMethodName(targetClass, targetAttr);
                        sb.AppendLine(prop.IsNullable()
                            ? $"\t\t\tresult.{comPropName} = src.{netPropName}?.{enumToComMethod}();"
                            : $"\t\t\tresult.{comPropName} = src.{netPropName}.{enumToComMethod}();");
                    }
                    else if (DtoGenerationSymbols.IsComType(netPropType, comTypeDict))
                    {
                        var classType = netPropType.UnwrapNullableTypeSymbol();
                        var targetClass = comTypeDict[classType.ToDisplayString()];
                        var targetAttr = targetClass.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);
                        var propToComMethod = DtoGenerationSymbols.GetToComMethodName(targetClass, targetAttr);
                        sb.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName}?.{propToComMethod}();");
                    }
                    else
                    {
                        sb.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName};");
                    }
                }

                sb.AppendLine("\t\t\treturn result;");
                sb.AppendLine("\t\t}");

                sb.AppendLine($"\t\tpublic static {netTypeName} ToNet{genericParams}(this {comTypeName}{genericParams} src)");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(src == null) return null;");
                sb.AppendLine($"\t\t\tvar result = new {netTypeName}();");
                foreach (var prop in comProps)
                {
                    var propAttr = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(_symbols.PropertySetting);
                    var netPropName = prop.Name;
                    var comPropName = DtoGenerationSymbols.GetComPropertyName(prop, propAttr);
                    var netPropType = prop.Type;

                    if (DtoGenerationSymbols.IsComEnumType(netPropType, comTypeDict))
                        sb.AppendLine(prop.IsNullable()
                            ? $"\t\t\tresult.{netPropName} = src.{comPropName}?.ToNet();"
                            : $"\t\t\tresult.{netPropName} = src.{comPropName}.ToNet();");
                    else if (DtoGenerationSymbols.IsComType(netPropType, comTypeDict))
                        sb.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName}?.ToNet();");
                    else
                        sb.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName};");
                }
                sb.AppendLine("\t\t\treturn result;");
                sb.AppendLine("\t\t}");
            }

            sb.AppendLine("\t}");
        }

        return new DtoGeneratedFile("MappingExtensions.g.cs", ns, sb.ToString(), new[] { "System" });
    }

    public string GenerateGuids()
    {
        if (!_comIds.Any()) return string.Empty;

        var sb = new StringBuilder();
        sb.AppendLine("\t#region ComGuids");
        sb.AppendLine($"\t{_config.ComIdClassModifier} static partial class {_config.ComIdClassName}");
        sb.AppendLine("\t{");
        foreach (var kv in _comIds)
            sb.AppendLine($"\t\tpublic const string {string.Format(_config.ComIdClassPropertyFormat, kv.Key)} = \"{kv.Value}\";");
        sb.AppendLine("\t}");
        sb.AppendLine("\t#endregion ComGuids");
        return sb.ToString();
    }

    public string GenerateEnum(INamedTypeSymbol enumType, AutoGenerateDtoAttribute classAttr, Dictionary<string, INamedTypeSymbol> comTypeDict)
    {
        var comName = DtoGenerationSymbols.GetComClassName(enumType, classAttr, false);
        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{enumType.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf("\t[ComVisible(true)]", classAttr.IsComCompatible);
        if (classAttr.IsComCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLine($"\t{_config.ClassModifier} enum {comName}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>().Where(f => f.IsConst))
        {
            if (_symbols.Ignore != null && member.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, _symbols.Ignore)))
                continue;
            if (_config.CreateComments) sb.AppendLine($"\t\t/// <summary>{member.Name}</summary>");
            sb.AppendLineIf($"\t\t[DispId({++dispId})]", classAttr.IsComCompatible);
            sb.AppendLine($"\t\t{member.Name} = {member.ConstantValue},");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public string GenerateInterface(INamedTypeSymbol type, 
        AutoGenerateDtoAttribute classAttr, 
        Dictionary<string, INamedTypeSymbol> comTypeDict, 
        bool addGeneric)
    {
        var comInterfaceName = DtoGenerationSymbols.GetComClassName(type, classAttr, true);
        var comName = DtoGenerationSymbols.GetComClassName(type, classAttr, false);
        var genericParams = addGeneric ? DtoGenerationSymbols.GetGenericTypeParameters(type): "";
        var comCompatible = classAttr.IsComCompatible;

        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comInterfaceName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf("\t[ComVisible(true)]", comCompatible);
        if (comCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLineIf("\t[TypeLibType(TypeLibTypeFlags.FDual | TypeLibTypeFlags.FDispatchable)]", comCompatible);
        sb.AppendLine($"\t{_config.InterfaceModifier} {(_config.GeneratePartial ? "partial " : "")}interface {comInterfaceName}{genericParams}");
        sb.AppendLine("\t{");
        int dispId = 0;
        foreach (var prop in DtoGenerationSymbols.GetComProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(_symbols.PropertySetting);
            var propTypeString = DtoGenerationSymbols.GetComPropertyType(prop, comTypeDict, _symbols, true);
            var propName = DtoGenerationSymbols.GetComPropertyName(prop, propAttr);
            sb.AppendLineIf($"\t\t[DispId({++dispId})]", comCompatible);
            sb.AppendLine($"\t\t{propTypeString} {propName} {{ get; set; }}");
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public string GenerateClass(INamedTypeSymbol type, AutoGenerateDtoAttribute classAttr,
        Dictionary<string, INamedTypeSymbol> comTypeDict,
        bool addGeneric)
    {
        var comName = DtoGenerationSymbols.GetComClassName(type, classAttr, false);
        var comInterfaceName = DtoGenerationSymbols.GetComClassName(type, classAttr, true);
        var genericParams = addGeneric ? DtoGenerationSymbols.GetGenericTypeParameters(type) : "";
        var comCompatible = classAttr.IsComCompatible;

        var sb = new StringBuilder();
        if (_config.CreateComments)
            sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
        sb.AppendLineIf($"\t[ComVisible(true)]", comCompatible);
        if (comCompatible)
            sb.AppendLine($"\t[Guid({GetGuid(comName).ClassName})]");
        sb.AppendLine($"\t{_config.ClassModifier} {(_config.GeneratePartial ? "partial " : "")}class {comName}{genericParams} : {comInterfaceName}{genericParams}");
        sb.AppendLine("\t{");
        foreach (var prop in DtoGenerationSymbols.GetComProperties(type, _symbols.Ignore))
        {
            var propAttr = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(_symbols.PropertySetting);
            var propTypeString = DtoGenerationSymbols.GetComPropertyType(prop, comTypeDict, _symbols, false);
            var propName = DtoGenerationSymbols.GetComPropertyName(prop, propAttr);
            sb.AppendLine($"\t\tpublic {propTypeString} {propName} {{ get; set; }}");
        }
        foreach (var prop in DtoGenerationSymbols.GetComProperties(type, _symbols.Ignore))
        {
            var propType = prop.Type;
            if (DtoGenerationSymbols.IsComType(propType, comTypeDict) && !DtoGenerationSymbols.IsComEnumType(propType, comTypeDict))
            {
                var propAttr = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(_symbols.PropertySetting);
                var targetClass = comTypeDict[propType.ToDisplayString()];
                var targetAttr = targetClass.GetAttributeInstance<AutoGenerateDtoAttribute>(_symbols.AutoGenerateDto);
                var propTypeString = DtoGenerationSymbols.GetComPropertyType(prop, comTypeDict, _symbols, false);
                var comInterfaceTypeName = DtoGenerationSymbols.GetComClassName(targetClass, targetAttr, true);
                var thisInterface = comInterfaceName;
                var propName = DtoGenerationSymbols.GetComPropertyName(prop, propAttr);
                sb.AppendLine($"\t\t{comInterfaceTypeName} {thisInterface}.{propName} {{ get => {propName}; set => {propName} = ({propTypeString})value; }}");
            }
        }
        sb.AppendLine("\t}\n");
        return sb.ToString();
    }

    public DtoGeneratedFile GenerateComIdFile(IEnumerable<INamedTypeSymbol> allTypes)
    {
        if (!_comIds.Any())
            return null;

        var ns = _config.Namespace;
        var usings = new[] { "System" };
        var sb = new StringBuilder();
        sb.AppendFileHeader();
        sb.AppendUsings(usings);
        sb.OpenNamespace(ns);
        sb.AppendLine(GenerateGuids());
        sb.CloseNamespace();

        var fileName = $"{_config.ComIdClassName}.g.cs";
        return new DtoGeneratedFile(fileName, ns, sb.ToString(), usings);
    }

    public (string Id, string ClassName) GetGuid(string className)
    {
        if (!_comIds.TryGetValue(className, out var guid))
        {
            guid = Guid.NewGuid().ToString();
            _comIds[className] = guid;
        }
        return (guid, $"{_config.ComIdClassName}.{string.Format(_config.ComIdClassPropertyFormat, className)}");
    }
}
