using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Nextended.CodeGen.Attributes;
using Nextended.CodeGen.Contracts;
using System.Text;
using Nextended.CodeGen.Helper;
using Nextended.Core.Extensions;
using System.Collections.Generic;

namespace Nextended.CodeGen.Generators;

public class DtoSourceGenerator : ISourceSubGenerator<object>
{
    // Settings
    private const string DefaultPrefix = "Com";
    private const string DefaultNamespace = "CP.Server.Embedded.COM.AutoGenerated";
    private const string ComIdClassName = "ComGuids";
    private const string ComIdFormat = "Id{0}";
    private const string ComIdClassModifier = "internal";
    private const string ClassModifier = "public";
    private const string InterfaceModifier = "public";
    private const bool CreateRegions = true;
    private const bool CreateComments = true;
    private const bool GeneratePartial = true;

    // State
    private readonly Dictionary<string, string> _comIds = new();

    public void Execute(GeneratorExecutionContext context, IEnumerable<object> settings, AdditionalText additionalFile)
    {
        var symbols = SymbolTypes.Collect(context.Compilation);
        if (symbols.AutoGenerateDto == null) return;

        var types = Helpers.FindTypesWithAttribute(context.Compilation, symbols.AutoGenerateDto);
        var comTypeDict = types.ToDictionary(t => t.ToDisplayString(), t => t);

        // 1. Klassen, Interfaces, Enums
        var code = new StringBuilder();
        ComCode.EmitHeader(code, types);
        ComCode.EmitNamespaceOpen(code);

        int classCount = 0, interfaceCount = 0, enumCount = 0;

        foreach (var type in types)
        {
            if (type.TypeKind == TypeKind.Enum)
            {
                ComCode.EmitEnum(code, type, symbols, ref enumCount, _comIds);
                continue;
            }

            ComCode.EmitClassAndInterface(code, type, symbols, comTypeDict, _comIds, ref classCount, ref interfaceCount);
        }

        ComCode.EmitGuids(code, _comIds);
        ComCode.EmitFooter(code, classCount, interfaceCount, enumCount);

        context.AddSource("ComClasses.g.cs", code.ToString());

        // 2. Mapping Extensions
        var mapCode = new StringBuilder();
        MapCode.EmitMappingExtensions(mapCode, types, symbols, comTypeDict);
        context.AddSource("ComMappingExtensions.g.cs", mapCode.ToString());
    }

    // --- Helpers & Subcomponents ---
    class SymbolTypes
    {
        public INamedTypeSymbol? AutoGenerateDto, Ignore, PropertySetting;
        public static SymbolTypes Collect(Compilation c) => new()
        {
            AutoGenerateDto = c.GetTypeByMetadataName(typeof(AutoGenerateDtoAttribute).FullName!),
            Ignore = c.GetTypeByMetadataName(typeof(IgnoreOnGenerationAttribute).FullName!),
            PropertySetting = c.GetTypeByMetadataName(typeof(GenerationPropertySettingAttribute).FullName!)
        };
    }

    static class Helpers
    {
        public static List<INamedTypeSymbol> FindTypesWithAttribute(
            Compilation compilation, params INamedTypeSymbol[] attributeTypes)
        {

            var res = new List<INamedTypeSymbol>();
            foreach (var attributeType in attributeTypes)
            {
                res.AddRange((from tree in compilation.SyntaxTrees
                        let model = compilation.GetSemanticModel(tree)
                        let typeNodes = tree.GetRoot()
                            .DescendantNodes()
                            .Where(n => n is TypeDeclarationSyntax or EnumDeclarationSyntax)
                        from node in typeNodes
                        select model.GetDeclaredSymbol(node)).OfType<INamedTypeSymbol>()
                    .Where(symbol => symbol.GetAttributes().Any(a =>
                        SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeType)))
                    .ToList());
            }
            return res.Distinct().ToList();
        }

        public static string GetToComMethodName(INamedTypeSymbol type, INamedTypeSymbol autoGenAttr)
        {
            var info = type.GetAttributeInstance<AutoGenerateDtoAttribute>(autoGenAttr);
            if (!string.IsNullOrWhiteSpace(info.ToDtoMethodName))
                return info.ToDtoMethodName;
            return $"To{info.Prefix}{info.Suffix}";
        }

        public static string GetComClassName(INamedTypeSymbol type, INamedTypeSymbol autoGenAttr, bool asInterface)
        {
            var info = type.GetAttributeInstance<AutoGenerateDtoAttribute>(autoGenAttr);

            string main = !string.IsNullOrEmpty(info.GeneratedClassName) ? info.GeneratedClassName : type.Name;
            int idx = main.IndexOf('`');
            if (idx >= 0) main = main.Substring(0, idx);

            return $"{(asInterface ? "I" : "")}{info.Prefix}{main}{info.Suffix}";
        }

        public static string GetComPropertyName(IPropertySymbol prop, INamedTypeSymbol? settingAttr)
        {
            var info = prop.GetAttributeInstance<GenerationPropertySettingAttribute>(settingAttr);
            return !string.IsNullOrEmpty(info?.PropertyName) ? info.PropertyName : prop.Name;
        }
        public static IEnumerable<IPropertySymbol> GetComProperties(INamedTypeSymbol type, INamedTypeSymbol? ignoreAttr)
            => type.GetMembers().OfType<IPropertySymbol>().Where(p =>
                p.DeclaredAccessibility == Accessibility.Public &&
                !p.IsStatic &&
                (ignoreAttr == null || !p.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, ignoreAttr)))
            );



        public static bool IsComType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
            => comTypes.ContainsKey(type.ToDisplayString());
        public static bool IsComEnumType(ITypeSymbol type, Dictionary<string, INamedTypeSymbol> comTypes)
        {
            if (type is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nts)
                type = nts.TypeArguments[0];
            return comTypes.TryGetValue(type.ToDisplayString(), out var t) && t.TypeKind == TypeKind.Enum;
        }
        public static string GetComPropertyType(IPropertySymbol prop, Dictionary<string, INamedTypeSymbol> comTypes, INamedTypeSymbol autoGenAttr, bool asInterface)
        {
            var propType = prop.Type;
            bool isNullable = false;
            ITypeSymbol underlyingType = propType;
            if (propType is INamedTypeSymbol { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.System_Nullable_T } nts)
            {
                isNullable = true;
                underlyingType = nts.TypeArguments[0];
            }
            string typeString;
            if (IsComEnumType(underlyingType, comTypes))
                typeString = GetComClassName(comTypes[underlyingType.ToDisplayString()], autoGenAttr, false);
            else if (IsComType(underlyingType, comTypes))
                typeString = GetComClassName(comTypes[underlyingType.ToDisplayString()], autoGenAttr, asInterface);
            else
                typeString = underlyingType.ToDisplayString();
            if (isNullable && !typeString.EndsWith("?"))
                typeString += "?";
            return typeString;
        }
        public static (string Id, string ClassName) GetGuid(string className, Dictionary<string, string> comIds)
        {
            if (!comIds.TryGetValue(className, out var guid))
            {
                guid = Guid.NewGuid().ToString();
                comIds[className] = guid;
            }
            return (guid, $"{ComIdClassName}.{string.Format(ComIdFormat, className)}");
        }
    }

    static class ComCode
    {
        public static void EmitHeader(StringBuilder sb, IEnumerable<INamedTypeSymbol> types)
        {
            sb.AppendFileHeader("Classes")
              .AppendUsings(types.Select(t => t.ContainingNamespace.ToDisplayString())
                  .Concat(["System", "System.Runtime.InteropServices"])
                  .Where(n => !string.IsNullOrWhiteSpace(n))
                  .Distinct().ToArray());
        }
        public static void EmitNamespaceOpen(StringBuilder sb)
        {
            sb.AppendLine($"namespace {DefaultNamespace}");
            sb.AppendLine("{");
            if (CreateRegions) sb.AppendLine("\t#region GENERATED CLASSES");
        }
        public static void EmitFooter(StringBuilder sb, int c, int i, int e)
        {
            sb.AppendLine($"\t// END CLASS GENERATION - GENERATED {c} CLASSES, {i} INTERFACES and {e} ENUMS");
            if (CreateRegions) sb.AppendLine("\t#endregion GENERATED CLASSES");
            sb.AppendLine("}");
        }
        public static void EmitGuids(StringBuilder sb, Dictionary<string, string> comIds)
        {
            if (!comIds.Any())
                return;
            sb.AppendLine("\t#region ComGuids");
            sb.AppendLine($"\t{ComIdClassModifier} static partial class {ComIdClassName}");
            sb.AppendLine("\t{");
            foreach (var kv in comIds)
                sb.AppendLine($"\t\tpublic const string {string.Format(ComIdFormat, kv.Key)} = \"{kv.Value}\";");
            sb.AppendLine("\t}");
            sb.AppendLine("\t#endregion ComGuids");
        }
        public static void EmitEnum(StringBuilder sb, INamedTypeSymbol enumType, SymbolTypes symbols, ref int count, Dictionary<string, string> comIds)
        {
            var info = enumType.GetAttributeInstance<AutoGenerateDtoAttribute>(symbols.AutoGenerateDto!);

            var comName = Helpers.GetComClassName(enumType, symbols.AutoGenerateDto!, false); // TODO: Create method with AutoGenerateComAttribute
            if (CreateComments) sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{enumType.ToDisplayString()}\"/></summary>");
            sb.AppendLineIf("\t[ComVisible(true)]", info.IsComCompatible);
            if(info.IsComCompatible)
                sb.AppendLine($"\t[Guid({Helpers.GetGuid(comName, comIds).ClassName})]");
            sb.AppendLine($"\t{ClassModifier} enum {comName}");
            sb.AppendLine("\t{");
            int dispId = 0;
            foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>().Where(f => f.IsConst))
            {
                if (symbols.Ignore != null && member.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, symbols.Ignore)))
                    continue;
                if (CreateComments) sb.AppendLine($"\t\t/// <summary>{member.Name}</summary>");
                sb.AppendLineIf($"\t\t[DispId({++dispId})]", info.IsComCompatible);
                sb.AppendLine($"\t\t{member.Name} = {member.ConstantValue},");
            }
            sb.AppendLine("\t}\n");
            count++;
        }
        public static void EmitClassAndInterface(StringBuilder sb, INamedTypeSymbol type, SymbolTypes symbols, Dictionary<string, INamedTypeSymbol> comTypeDict, Dictionary<string, string> comIds, ref int c, ref int i)
        {
            var info = type.GetAttributeInstance<AutoGenerateDtoAttribute>(symbols.AutoGenerateDto!);
            var comName = Helpers.GetComClassName(type, symbols.AutoGenerateDto!, false); // TODO: Create method with AutoGenerateComAttribute
            var comInterfaceName = Helpers.GetComClassName(type, symbols.AutoGenerateDto!, true);
            if (CreateRegions) sb.AppendLine($"\t#region COM For {comName}");

            // Interface
            if (CreateComments)
                sb.AppendLine($"\t/// <summary>{comInterfaceName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
            sb.AppendLineIf($"\t[ComVisible(true)]", info.IsComCompatible);
            if (info.IsComCompatible)
                sb.AppendLine($"\t[Guid({Helpers.GetGuid(comName, comIds).ClassName})]");
            sb.AppendLineIf("\t[TypeLibType(TypeLibTypeFlags.FDual | TypeLibTypeFlags.FDispatchable)]", info.IsComCompatible);
            sb.AppendLine($"\t{InterfaceModifier} {(GeneratePartial ? "partial " : "")}interface {comInterfaceName}");
            sb.AppendLine("\t{");
            int dispId = 0;
            foreach (var prop in Helpers.GetComProperties(type, symbols.Ignore))
            {
                var propTypeString = Helpers.GetComPropertyType(prop, comTypeDict, symbols.AutoGenerateDto!, true);
                var propName = Helpers.GetComPropertyName(prop, symbols.PropertySetting);
                sb.AppendLineIf($"\t\t[DispId({++dispId})]", info.IsComCompatible);
                sb.AppendLine($"\t\t{propTypeString} {propName} {{ get; set; }}");
            }
            sb.AppendLine("\t}\n");
            i++;

            // Klasse
            if (CreateComments)
                sb.AppendLine($"\t/// <summary>{comName} - GENERATED FROM <see cref=\"T:{type.ToDisplayString()}\"/></summary>");
            sb.AppendLineIf($"\t[ComVisible(true)]", info.IsComCompatible);
            if(info.IsComCompatible)
                sb.AppendLine($"\t[Guid({Helpers.GetGuid(comName, comIds).ClassName})]");
            sb.AppendLine($"\t{ClassModifier} {(GeneratePartial ? "partial " : "")}class {comName} : {comInterfaceName}");
            sb.AppendLine("\t{");
            foreach (var prop in Helpers.GetComProperties(type, symbols.Ignore))
            {
                var propTypeString = Helpers.GetComPropertyType(prop, comTypeDict, symbols.AutoGenerateDto!, false);
                var propName = Helpers.GetComPropertyName(prop, symbols.PropertySetting);
                sb.AppendLine($"\t\tpublic {propTypeString} {propName} {{ get; set; }}");
            }
            foreach (var prop in Helpers.GetComProperties(type, symbols.Ignore))
            {
                var propType = prop.Type;
                if (Helpers.IsComType(propType, comTypeDict) && !Helpers.IsComEnumType(propType, comTypeDict))
                {
                    var propTypeString = Helpers.GetComPropertyType(prop, comTypeDict, symbols.AutoGenerateDto!, false);
                    var comInterfaceTypeName = Helpers.GetComClassName(comTypeDict[propType.ToDisplayString()], symbols.AutoGenerateDto!, true);
                    var thisInterface = comInterfaceName;
                    var propName = Helpers.GetComPropertyName(prop, symbols.PropertySetting);
                    sb.AppendLine($"\t\t{comInterfaceTypeName} {thisInterface}.{propName} {{ get => {propName}; set => {propName} = ({propTypeString})value; }}");
                }
            }
            sb.AppendLine("\t}\n");
            c++;
            if (CreateRegions) sb.AppendLine($"\t#endregion COM For {comName}");
        }
    }

    static class MapCode
    {
        public static void EmitMappingExtensions(StringBuilder sb, List<INamedTypeSymbol> types, SymbolTypes symbols, Dictionary<string, INamedTypeSymbol> comTypeDict)
        {
            sb.AppendLine("using System;");
            sb.AppendLine($"namespace {DefaultNamespace}");
            sb.AppendLine("{");
            sb.AppendLine("\tpublic static partial class MappingExtensions");
            sb.AppendLine("\t{");

            foreach (var type in types)
            {
                var toComMethodName = Helpers.GetToComMethodName(type, symbols.AutoGenerateDto!);
                var isEnum = type.TypeKind == TypeKind.Enum;
                var netTypeName = type.ToDisplayString();
                var comTypeName = Helpers.GetComClassName(type, symbols.AutoGenerateDto!, false);
                if (isEnum)
                {
                    // Nullable
                    sb.AppendLine($"\t\tpublic static {comTypeName}? {toComMethodName}(this {netTypeName}? src) => src.HasValue ? ({comTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\tpublic static {netTypeName}? ToNet(this {comTypeName}? src) => src.HasValue ? ({netTypeName})(int)src.Value : null;");
                    sb.AppendLine($"\t\tpublic static {comTypeName} {toComMethodName}(this {netTypeName} src) => ({comTypeName})(int)src;");
                    sb.AppendLine($"\t\tpublic static {netTypeName} ToNet(this {comTypeName} src) => ({netTypeName})(int)src;");
                    continue;
                }

                var comProps = Helpers.GetComProperties(type, symbols.Ignore).ToList();

                // ToCom
                sb.AppendLine($"\t\tpublic static {comTypeName} {toComMethodName}(this {netTypeName} src)");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(src == null) return null;");
                sb.AppendLine($"\t\t\tvar result = new {comTypeName}();");
                foreach (var prop in comProps)
                {
                    var netPropName = prop.Name;
                    var comPropName = Helpers.GetComPropertyName(prop, symbols.PropertySetting);
                    var netPropType = prop.Type;

                    if (Helpers.IsComEnumType(netPropType, comTypeDict))
                    {
                        var enumType = netPropType.UnwrapNullableTypeSymbol();
                        var enumToComMethod = Helpers.GetToComMethodName(comTypeDict[enumType.ToDisplayString()], symbols.AutoGenerateDto!);

                        sb.AppendLine(prop.IsNullable()
                            ? $"\t\t\tresult.{comPropName} = src.{netPropName}?.{enumToComMethod}();"
                            : $"\t\t\tresult.{comPropName} = src.{netPropName}.{enumToComMethod}();");
                    }
                    else if (Helpers.IsComType(netPropType, comTypeDict))
                    {
                        var classType = netPropType.UnwrapNullableTypeSymbol();
                        var propToComMethod = Helpers.GetToComMethodName(comTypeDict[classType.ToDisplayString()], symbols.AutoGenerateDto!);

                        sb.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName}?.{propToComMethod}();");
                    }
                    else
                    {
                        sb.AppendLine($"\t\t\tresult.{comPropName} = src.{netPropName};");
                    }
                }

                sb.AppendLine("\t\t\treturn result;");
                sb.AppendLine("\t\t}");

                // ToNet
                sb.AppendLine($"\t\tpublic static {netTypeName} ToNet(this {comTypeName} src)");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(src == null) return null;");
                sb.AppendLine($"\t\t\tvar result = new {netTypeName}();");
                foreach (var prop in comProps)
                {
                    var netPropName = prop.Name;
                    var comPropName = Helpers.GetComPropertyName(prop, symbols.PropertySetting);
                    var netPropType = prop.Type;

                    if (Helpers.IsComEnumType(netPropType, comTypeDict))
                        sb.AppendLine(prop.IsNullable()
                            ? $"\t\t\tresult.{netPropName} = src.{comPropName}?.ToNet();"
                            : $"\t\t\tresult.{netPropName} = src.{comPropName}.ToNet();");
                    else if (Helpers.IsComType(netPropType, comTypeDict))
                        sb.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName}?.ToNet();");
                    else
                        sb.AppendLine($"\t\t\tresult.{netPropName} = src.{comPropName};");
                }
                sb.AppendLine("\t\t\treturn result;");
                sb.AppendLine("\t\t}");
            }

            sb.AppendLine("\t}");
            sb.AppendLine("}");
        }
    }
}
