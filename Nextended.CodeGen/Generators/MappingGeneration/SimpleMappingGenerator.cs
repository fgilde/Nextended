using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Nextended.CodeGen.Generators.MappingGeneration
{
    [Generator]
    public class SimpleMappingGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // Register syntax receiver to find types with attributes
            context.RegisterForSyntaxNotifications(() => new AttributeSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is AttributeSyntaxReceiver receiver))
                return;

            // Add a simple test file first to verify the generator works
            var testSource = @"// <auto-generated />
namespace Nextended.Core.Generated
{
    public static class GeneratedMappingTest
    {
        public static string GetMessage() => ""Source generator is working!"";
    }
}";
            context.AddSource("GeneratedMappingTest.g.cs", SourceText.From(testSource, Encoding.UTF8));

            // Process types with GenerateMapper attribute
            foreach (var candidateClass in receiver.CandidateClasses)
            {
                var model = context.Compilation.GetSemanticModel(candidateClass.SyntaxTree);
                var classSymbol = model.GetDeclaredSymbol(candidateClass);

                if (classSymbol == null)
                    continue;

                // Check if this class has our attribute
                if (classSymbol.GetAttributes().Any(attr => 
                    attr.AttributeClass?.Name == "GenerateMapperAttribute"))
                {
                    var source = GenerateMappingExtensions(classSymbol);
                    context.AddSource($"{classSymbol.Name}MappingExtensions.g.cs", 
                        SourceText.From(source, Encoding.UTF8));
                }
            }
        }

        private string GenerateMappingExtensions(INamedTypeSymbol classSymbol)
        {
            var className = $"{classSymbol.Name}MappingExtensions";
            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            return $@"// <auto-generated />
using System;
using System.Runtime.CompilerServices;

namespace {namespaceName}
{{
    /// <summary>
    /// Generated mapping extensions for {classSymbol.Name}
    /// </summary>
    public static partial class {className}
    {{
        /// <summary>
        /// Example generated method for {classSymbol.Name}
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string GetGeneratedMessage(this {classSymbol.ToDisplayString()} source)
        {{
            return $""Generated mapping for {{typeof({classSymbol.ToDisplayString()}).Name}}"";
        }}
    }}
}}";
        }
    }

    internal class AttributeSyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Look for class declarations with attributes
            if (syntaxNode is ClassDeclarationSyntax classDeclaration && 
                classDeclaration.AttributeLists.Count > 0)
            {
                CandidateClasses.Add(classDeclaration);
            }
        }
    }
}