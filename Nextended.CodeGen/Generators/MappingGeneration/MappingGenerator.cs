using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Nextended.CodeGen.Contracts;

namespace Nextended.CodeGen.Generators.MappingGeneration
{
    public class MappingGenerator : ISourceSubGenerator
    {
        public bool RequireConfig => false;

        public IEnumerable<GeneratedFile> Execute(GenerationContext context)
        {
            var compilation = context.ExecutionContext.Compilation;
            var semanticModel = compilation.GetSemanticModel(compilation.SyntaxTrees.First());

            // Find types marked with GenerateMapperAttribute
            var typesWithMapperAttribute = FindTypesWithMapperAttribute(compilation);

            foreach (var typeSymbol in typesWithMapperAttribute)
            {
                var generatedFile = GenerateMappingExtensions(typeSymbol, compilation);
                if (generatedFile != null)
                {
                    yield return generatedFile;
                }
            }
        }

        private IEnumerable<INamedTypeSymbol> FindTypesWithMapperAttribute(Compilation compilation)
        {
            var generateMapperAttribute = compilation.GetTypeByMetadataName("Nextended.Core.Attributes.GenerateMapperAttribute");
            if (generateMapperAttribute == null)
                yield break;

            foreach (var syntaxTree in compilation.SyntaxTrees)
            {
                var semanticModel = compilation.GetSemanticModel(syntaxTree);
                var root = syntaxTree.GetCompilationUnitRoot();

                foreach (var typeDeclaration in root.DescendantNodes().OfType<TypeDeclarationSyntax>())
                {
                    var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol;
                    if (typeSymbol == null) continue;

                    if (typeSymbol.GetAttributes().Any(attr => 
                        SymbolEqualityComparer.Default.Equals(attr.AttributeClass, generateMapperAttribute)))
                    {
                        yield return typeSymbol;
                    }
                }
            }
        }

        private GeneratedFile? GenerateMappingExtensions(INamedTypeSymbol typeSymbol, Compilation compilation)
        {
            var mapToAttribute = compilation.GetTypeByMetadataName("Nextended.Core.Attributes.MapToAttribute");
            
            // Get MapTo attributes to find target types
            var mapToAttributes = typeSymbol.GetAttributes()
                .Where(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, mapToAttribute))
                .ToList();

            if (!mapToAttributes.Any())
            {
                // If no MapTo attributes, generate a generic mapper
                return GenerateGenericMapper(typeSymbol);
            }

            return GenerateSpecificMappers(typeSymbol, mapToAttributes, compilation);
        }

        private GeneratedFile GenerateGenericMapper(INamedTypeSymbol typeSymbol)
        {
            var className = $"{typeSymbol.Name}MappingExtensions";
            var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
            
            var properties = GetMappableProperties(typeSymbol);
            
            var code = $@"// <auto-generated />
using System;
using System.Runtime.CompilerServices;

namespace {namespaceName}
{{
    /// <summary>
    /// Generated mapping extensions for {typeSymbol.Name}
    /// </summary>
    public static partial class {className}
    {{
        /// <summary>
        /// Maps {typeSymbol.Name} to target type T using generated code instead of reflection
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T MapTo<T>(this {typeSymbol.ToDisplayString()} source) where T : new()
        {{
            if (source == null) return default(T);
            
            var target = new T();
            var targetType = typeof(T);
            
            // This would need property-specific generated code for optimal performance
            // For now, providing a hook for manual implementation
            return MapToInternal<T>(source, target);
        }}
        
        private static T MapToInternal<T>(this {typeSymbol.ToDisplayString()} source, T target)
        {{
            // Generated property mapping would go here
            // For demonstration, using reflection fallback
            return (T)Nextended.Core.Extensions.ClassMappingExtensions.MapTo(source, typeof(T));
        }}
    }}
}}";

            return new GeneratedFile($"{className}.g.cs", namespaceName, code);
        }

        private GeneratedFile GenerateSpecificMappers(INamedTypeSymbol typeSymbol, 
            List<AttributeData> mapToAttributes, Compilation compilation)
        {
            var className = $"{typeSymbol.Name}MappingExtensions";
            var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
            
            var methods = new List<string>();
            
            foreach (var attr in mapToAttributes)
            {
                if (attr.ConstructorArguments.Length > 0)
                {
                    var targetType = attr.ConstructorArguments[0].Value as INamedTypeSymbol;
                    if (targetType != null)
                    {
                        var method = GenerateMappingMethod(typeSymbol, targetType, attr);
                        methods.Add(method);
                    }
                }
            }

            var code = $@"// <auto-generated />
using System;
using System.Runtime.CompilerServices;

namespace {namespaceName}
{{
    /// <summary>
    /// Generated mapping extensions for {typeSymbol.Name}
    /// </summary>
    public static partial class {className}
    {{
{string.Join("\n\n", methods)}
    }}
}}";

            return new GeneratedFile($"{className}.g.cs", namespaceName, code);
        }

        private string GenerateMappingMethod(INamedTypeSymbol sourceType, INamedTypeSymbol targetType, AttributeData attribute)
        {
            var methodName = GetMethodName(targetType, attribute);
            var targetTypeName = targetType.ToDisplayString();
            
            var sourceProperties = GetMappableProperties(sourceType);
            var targetProperties = GetMappableProperties(targetType).ToDictionary(p => p.Name, p => p);
            
            var mappingStatements = new List<string>();
            
            foreach (var sourceProp in sourceProperties)
            {
                if (targetProperties.TryGetValue(sourceProp.Name, out var targetProp))
                {
                    if (CanMapDirectly(sourceProp.Type, targetProp.Type))
                    {
                        mappingStatements.Add($"            target.{targetProp.Name} = source.{sourceProp.Name};");
                    }
                    else
                    {
                        // For complex types, we might need recursive mapping or conversion
                        mappingStatements.Add($"            // TODO: Handle complex mapping for {sourceProp.Name}");
                        mappingStatements.Add($"            target.{targetProp.Name} = source.{sourceProp.Name}; // Simple assignment for now");
                    }
                }
            }

            return $@"        /// <summary>
        /// Maps {sourceType.Name} to {targetType.Name} using generated code instead of reflection
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static {targetTypeName} {methodName}(this {sourceType.ToDisplayString()} source)
        {{
            if (source == null) return default({targetTypeName});
            
            var target = new {targetTypeName}();
{string.Join("\n", mappingStatements)}
            
            return target;
        }}";
        }

        private string GetMethodName(INamedTypeSymbol targetType, AttributeData attribute)
        {
            // Check if MethodName property is set in the attribute
            var methodNameArg = attribute.NamedArguments.FirstOrDefault(arg => arg.Key == "MethodName");
            if (!methodNameArg.Equals(default(KeyValuePair<string, TypedConstant>)) && 
                methodNameArg.Value.Value is string customName && !string.IsNullOrEmpty(customName))
            {
                return customName;
            }
            
            return $"To{targetType.Name}";
        }

        private bool CanMapDirectly(ITypeSymbol sourceType, ITypeSymbol targetType)
        {
            // Check if types can be mapped directly (same type, implicit conversion, etc.)
            return SymbolEqualityComparer.Default.Equals(sourceType, targetType) ||
                   sourceType.CanBeReferencedByName && targetType.CanBeReferencedByName &&
                   sourceType.ToDisplayString() == targetType.ToDisplayString();
        }

        private List<IPropertySymbol> GetMappableProperties(INamedTypeSymbol typeSymbol)
        {
            var properties = new List<IPropertySymbol>();
            
            // Get all public instance properties that have both getter and setter
            foreach (var member in typeSymbol.GetMembers())
            {
                if (member is IPropertySymbol property &&
                    property.DeclaredAccessibility == Accessibility.Public &&
                    !property.IsStatic &&
                    !property.IsIndexer &&
                    property.GetMethod != null &&
                    property.SetMethod != null)
                {
                    properties.Add(property);
                }
            }
            
            return properties;
        }
    }
}