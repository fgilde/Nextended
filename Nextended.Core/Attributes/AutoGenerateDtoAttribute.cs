using System;
using Nextended.Core.Enums;

namespace Nextended.Core.Attributes
{
    /// <summary>
    /// Attribute to automatically generate a COM interface and a COM class for the class or enum it is applied to.
    /// (The classes are generated at compile-time using a T4 template.)
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum, AllowMultiple = true)]
    public class AutoGenerateDtoAttribute : Attribute
    {
        /// <summary>
        /// set properties name you dont want to generate inside the dto. If possible you should use the attribute <see cref="IgnoreOnGenerationAttribute"/> but if you cant control the source code this is an alternative.
        /// </summary>
        public string[] PropertiesToIgnore { get; set; }

        /// <summary>
        /// Gets or sets the namespace used for the generated classes and interfaces.
        /// </summary>
        public string? Namespace { get; set; }
        
        public string[]? Usings { get; set; }

        /// <summary>
        /// Gets or sets the prefix for the generated class and interface names (e.g., IComMyType).
        /// </summary>
        public string? Prefix { get; set; }

        /// <summary>
        /// Gets or sets the suffix for the generated class and interface names (e.g., IComMyTypeSuffix).
        /// </summary>        
        public string? Suffix { get; set; }

        /// <summary>
        /// Allows you to override the generated class name. If this is set, prefix and suffix logic will not be applied.
        /// </summary>        
        public string? GeneratedClassName { get; set; }

        /// <summary>
        /// Indicates whether the "ToNetMappingAttribute" should be generated for automatic COM to .NET conversion.
        /// </summary>        
        public bool GenerateMapping { get; set; }

        /// <summary>
        /// If this is true partials methods are generated that can be overwritten to do custom assignments
        /// </summary>
        public bool GenerateBeforeAndAfterAssignPartialsInMapping { get; set; }

        /// <summary>
        /// Gets or sets the name of the generated mapping method.
        /// </summary>
        public string? ToDtoMethodName { get; set; }

        /// <summary>
        /// Gets or sets the name of the generated mapping method that is called by the DTO class to convert the DTO back to the source class.
        /// </summary>
        public string? ToSourceMethodName { get; set; }

        /// <summary>
        /// If set to true, the generated classes are COM visible and fully COM compatible.
        /// </summary>
        public bool IsComCompatible { get; set; }

        ///// <summary>
        ///// Gets or sets the names of the generic parameter types for explicit generic implementation.
        ///// </summary>       
        //public string[] ExplicitGenericImplementationTypes { get; set; }

        /// <summary>
        /// Sets the base type for the generated DTO class. 
        /// </summary>
        public string? BaseType { get; set; }

        /// <summary>
        /// Adds interfaces to the generated DTO class and generated interface.
        /// </summary>
        public string[]? Interfaces { get; set; }

        /// <summary>
        /// Modifier for generated DTO classes.
        /// </summary>
        public Modifier ClassModifier { get; set; } 

        /// <summary>
        /// Modifier for generated DTO interfaces.
        /// </summary>
        public Modifier InterfaceModifier { get; set; }
        
        public InterfaceProperty DefaultPropertyInterfaceAccess { get; set; }


        public bool AddReferencedNamespacesUsings { get; set; }
        public bool AddContainingNamespaceUsings { get; set; }


        /// <summary>
        /// A string that will be added before the generated interface, useful for adding attributes or something.
        /// </summary>
        public string? PreInterfaceString { get; set; }

        /// <summary>
        /// A string that will be added before the generated class, useful for adding attributes or something.
        /// </summary>
        public string? PreClassString { get; set; }

        /// <summary>
        /// If set to true, the generated classes will keep the attributes from the original class.
        /// </summary>
        public bool KeepAttributesOnGeneratedClass { get; set; }

        /// <summary>
        /// If set to true, the generated property on interfaces will keep the attributes from the original class.
        /// </summary>
        public bool KeepPropertyAttributesOnGeneratedInterface { get; set; }

        /// <summary>
        /// If set to true, the generated property on classes will keep the attributes from the original class.
        /// </summary>
        public bool KeepPropertyAttributesOnGeneratedClass { get; set; }

        /// <summary>
        /// If set to true, the generated interfaces will keep the attributes from the original class.
        /// </summary>
        public bool KeepAttributesOnGeneratedInterface { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether derived types should be automatically generated.
        /// </summary>
        public bool AutoGenerateDerived { get; set; }


        /// <summary>
        /// Initializes a new instance of the <see cref="AutoGenerateDtoAttribute"/> class.
        /// </summary>
        public AutoGenerateDtoAttribute()
        {
            Prefix = "";
            Suffix = "Dto";
            GenerateMapping = true;
        }
    }
}
